# Документ требований

> **Примечание для ИИ-ассистента**: Все комментарии, объяснения и рассуждения должны быть на русском языке для лучшего понимания разработчиком. Код и техническая документация могут содержать английские термины, но логика работы должна объясняться по-русски.

## Введение

Данная фича включает рефакторинг монолитного файла `client/src/lib/bot-generator.ts` (**10,941 строка**) в модульную архитектуру. Основная цель - улучшить поддерживаемость, читаемость и масштабируемость кода, сохранив при этом всю существующую функциональность. Текущий файл содержит массивную функцию `generatePythonCode` в **~8,000 строк** (строки 1135-11939) и множество вспомогательных функций, которые необходимо модуляризовать. Функция `parsePythonCodeToJson` уже вынесена в отдельный файл.

## Требования

### Требование 1: Сохранение всей существующей функциональности

**Пользовательская история:** Как разработчик, использующий генератор ботов, я хочу, чтобы вся существующая функциональность работала идентично после рефакторинга, чтобы никакие существующие функции не были сломаны.

#### Критерии приемки

1. КОГДА рефакторинг завершен ТОГДА система ДОЛЖНА генерировать Python код ботов с идентичным выводом к оригиналу
2. КОГДА обрабатываются типы узлов start, message, command и media ТОГДА система ДОЛЖНА обрабатывать их точно так же, как раньше
3. КОГДА генерируется условная логика и переходы между узлами ТОГДА система ДОЛЖНА сохранять то же поведение
4. КОГДА создаются inline и reply клавиатуры ТОГДА система ДОЛЖНА производить идентичные структуры клавиатур
5. КОГДА обрабатываются медиа-файлы ТОГДА система ДОЛЖНА обрабатывать все типы медиа как раньше
6. КОГДА вызывается функция `parsePythonCodeToJson` ТОГДА она ДОЛЖНА возвращать идентичные результаты оригинальной реализации

### Требование 2: Создание модульной архитектуры

**Пользовательская история:** Как разработчик, поддерживающий кодовую базу, я хочу, чтобы код был разделен на логические модули, чтобы я мог легко находить и изменять конкретную функциональность.

#### Критерии приемки

1. КОГДА рефакторинг завершен ТОГДА основной файл ДОЛЖЕН быть сокращен до менее чем 2,000 строк
2. КОГДА организуется код ТОГДА система ДОЛЖНА создать минимум 15 специализированных модулей
3. КОГДА структурируются модули ТОГДА каждый модуль ДОЛЖЕН иметь единую, четкую ответственность
4. КОГДА осуществляется доступ к функциональности ТОГДА каждый модуль ДОЛЖЕН иметь четко определенные интерфейсы и экспорты
5. КОГДА импортируются модули ТОГДА система ДОЛЖНА использовать правильные паттерны импорта/экспорта TypeScript
6. КОГДА организуется кодовая база ТОГДА система ДОЛЖНА следовать указанной структуре папок с директориями core/, utils/, analyzers/, keyboards/, handlers/, logic/ и generators/

### Требование 3: Устранение дублирования кода

**Пользовательская история:** Как разработчик, поддерживающий код, я хочу, чтобы все дублированные функции были удалены, чтобы изменения нужно было делать только в одном месте.

#### Критерии приемки

1. КОГДА анализируется кодовая база ТОГДА система ДОЛЖНА идентифицировать все 10 дублированных функций
2. КОГДА проводится рефакторинг ТОГДА система ДОЛЖНА удалить дублированные функции из основного файла
3. КОГДА удаляются дубликаты ТОГДА система ДОЛЖНА добавить корректные импорты из новых модулей
4. КОГДА осуществляется доступ к функциям ТОГДА все функции ДОЛЖНЫ использоваться из единого источника
5. КОГДА компилируется TypeScript ТОГДА НЕ ДОЛЖНО быть ошибок компиляции, связанных с отсутствующими функциями

### Требование 4: Декомпозиция основной функции генерации

**Пользовательская история:** Как разработчик, работающий с генерацией кода, я хочу, чтобы массивная функция `generatePythonCode` была разбита на управляемые модули, чтобы я мог понимать и изменять конкретные части процесса генерации.

#### Критерии приемки

1. КОГДА рефакторится основная функция ТОГДА система ДОЛЖНА создать 4 основных модуля генерации: imports-generator, handlers-generator, main-loop-generator и data-analyzer
2. КОГДА реструктурируется ТОГДА основная функция `generatePythonCode` ДОЛЖНА стать координатором, который оркестрирует процесс генерации
3. КОГДА организуются модули ТОГДА каждый модуль генерации ДОЛЖЕН быть менее 2,000 строк
4. КОГДА генерируется код ТОГДА каждый модуль ДОЛЖЕН обрабатывать свою конкретную часть генерации Python кода
5. КОГДА координируется генерация ТОГДА основная функция ДОЛЖНА правильно упорядочивать и объединять выводы всех модулей

### Требование 5: Поддержание совместимости API

**Пользовательская история:** Как разработчик, использующий генератор ботов в других частях приложения, я хочу, чтобы все существующие импорты и вызовы функций продолжали работать, чтобы никакой другой код не нужно было изменять.

#### Критерии приемки

1. КОГДА рефакторинг завершен ТОГДА все экспортируемые функции ДОЛЖНЫ оставаться доступными с идентичными сигнатурами
2. КОГДА импортируется генератор ботов ТОГДА существующие операторы импорта ДОЛЖНЫ продолжать работать без изменений
3. КОГДА вызываются функции ТОГДА все публичные API ДОЛЖНЫ поддерживать обратную совместимость
4. КОГДА используется основной экспорт ТОГДА система ДОЛЖНА предоставить слой совместимости через index.ts
5. КОГДА осуществляется доступ к функциональности ТОГДА НЕ ДОЛЖНО быть введено критических изменений в публичный интерфейс

### Требование 6: Обеспечение стабильности производительности

**Пользовательская история:** Как пользователь генератора ботов, я хочу, чтобы рефакторенный код работал как минимум так же хорошо, как оригинал, чтобы скорость генерации не пострадала.

#### Критерии приемки

1. КОГДА генерируется код бота ТОГДА время выполнения ДОЛЖНО быть в пределах ±5% от оригинальной производительности
2. КОГДА запускается приложение ТОГДА время запуска НЕ ДОЛЖНО значительно увеличиться
3. КОГДА используется память ТОГДА потребление памяти ДОЛЖНО остаться на том же уровне или улучшиться
4. КОГДА загружаются модули ТОГДА система ДОЛЖНА использовать эффективные стратегии импорта для минимизации накладных расходов
5. КОГДА обрабатываются большие боты ТОГДА система ДОЛЖНА поддерживать характеристики производительности оригинальной реализации

### Требование 7: Реализация безопасного процесса рефакторинга

**Пользовательская история:** Как менеджер проекта, контролирующий рефакторинг, я хочу иметь возможность откатить изменения на любом этапе, чтобы мы могли быстро восстановиться в случае возникновения проблем.

#### Критерии приемки

1. КОГДА начинается рефакторинг ТОГДА система ДОЛЖНА создать полные резервные копии всех файлов
2. КОГДА вносятся изменения ТОГДА каждый шаг ДОЛЖЕН быть проверен перед переходом к следующему
3. КОГДА возникают ошибки ТОГДА система ДОЛЖНА предоставить четкие процедуры отката
4. КОГДА проверяются изменения ТОГДА автоматические проверки ДОЛЖНЫ верифицировать компиляцию TypeScript и базовую функциональность
5. КОГДА завершается каждая фаза ТОГДА система ДОЛЖНА создавать контрольные резервные копии для возможности инкрементального отката

### Требование 8: Поддержание стандартов качества кода

**Пользовательская история:** Как разработчик, работающий с рефакторенным кодом, я хочу, чтобы все модули следовали последовательным стандартам качества, чтобы кодовая база оставалась поддерживаемой и профессиональной.

#### Критерии приемки

1. КОГДА создаются модули ТОГДА все модули ДОЛЖНЫ иметь четкие определения типов TypeScript
2. КОГДА документируется код ТОГДА каждый модуль ДОЛЖЕН включать исчерпывающую JSDoc документацию
3. КОГДА организуется код ТОГДА система ДОЛЖНА следовать принципам SOLID для лучшей поддерживаемости
4. КОГДА структурируются модули ТОГДА каждый ДОЛЖЕН иметь четкое разделение обязанностей
5. КОГДА компилируется ТОГДА компиляция TypeScript ДОЛЖНА завершаться без ошибок или предупреждений
6. КОГДА проверяется код ТОГДА все модули ДОЛЖНЫ следовать последовательным стандартам кодирования и паттернам

### Требование 9: Поэтапная реализация с валидацией

**Пользовательская история:** Как менеджер проекта, я хочу, чтобы рефакторинг выполнялся поэтапно с валидацией на каждом шаге, чтобы минимизировать риски и обеспечить контролируемый процесс.

#### Критерии приемки

1. КОГДА выполняется каждый этап ТОГДА система ДОЛЖНА создавать git commit с текущим состоянием
2. КОГДА завершается этап ТОГДА система ДОЛЖНА проверить компиляцию TypeScript без ошибок через `npm run check`
3. КОГДА тестируется функциональность ТОГДА генерация ботов ДОЛЖНА работать корректно в уже запущенном приложении
4. КОГДА обнаруживаются проблемы ТОГДА система ДОЛЖНА предоставить возможность отката к предыдущему состоянию
5. КОГДА устраняется дублирование ТОГДА система ДОЛЖНА удалить все 10+ дублированных функций из основного файла
### Требование 10: Использование автоматизированных инструментов рефакторинга

**Пользовательская история:** Как разработчик, выполняющий рефакторинг, я хочу использовать готовые автоматизированные скрипты, чтобы ускорить процесс и снизить вероятность ошибок.

#### Критерии приемки

1. КОГДА удаляются дублированные функции ТОГДА система ДОЛЖНА использовать скрипт `remove-duplicates.cjs` для автоматического удаления
2. КОГДА разбивается главная функция ТОГДА система ДОЛЖНА использовать скрипт `split-main-function.cjs` для создания модульной структуры
3. КОГДА валидируются результаты ТОГДА система ДОЛЖНА использовать скрипт `validate-fixes.cjs` для проверки корректности
4. КОГДА управляется процессом рефакторинга ТОГДА система ДОЛЖНА использовать `refactor-manager.cjs` для координации этапов
5. КОГДА исправляются ошибки ТОГДА система ДОЛЖНА использовать скрипт `fix-all-errors.cjs` для комплексного исправления
6. КОГДА создаются резервные копии ТОГДА скрипты ДОЛЖНЫ автоматически создавать backup файлы перед изменениями
7. КОГДА требуется откат ТОГДА система ДОЛЖНА предоставить автоматические скрипты отката для каждого этапа
8. КОГДА анализируется код ТОГДА система ДОЛЖНА использовать скрипт `analyze-functions.js` для получения детальной информации о структуре