"""
ÐÐ¾Ð²Ñ‹Ð¹ Ð±Ð¾Ñ‚ 2 - Telegram Bot
Ð¡Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ TelegramBot Builder

ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð´Ð»Ñ @BotFather:
start - Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ð¾Ñ‚Ð°
settings - ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°"""

# -*- coding: utf-8 -*-
import os
import sys

# Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ UTF-8 ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÑƒ Ð´Ð»Ñ Ð²Ñ‹Ð²Ð¾Ð´Ð°
if sys.platform.startswith("win"):
    # Ð”Ð»Ñ Windows ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ UTF-8 ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÑƒ
    os.environ["PYTHONIOENCODING"] = "utf-8"
    try:
        import codecs
        sys.stdout.reconfigure(encoding="utf-8")
        sys.stderr.reconfigure(encoding="utf-8")
    except (AttributeError, UnicodeError):
        # Fallback Ð´Ð»Ñ ÑÑ‚Ð°Ñ€Ñ‹Ñ… Ð²ÐµÑ€ÑÐ¸Ð¹ Python
        import codecs
        sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
        sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())

import asyncio
import logging
import signal
import locale
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import CommandStart, Command
from aiogram.exceptions import TelegramBadRequest
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, BotCommand, ReplyKeyboardRemove, URLInputFile, FSInputFile
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from aiogram.enums import ParseMode
from typing import Optional
import asyncpg
from datetime import datetime, timezone, timedelta
import json
import aiohttp
from aiohttp import TCPConnector

# Safe helper for editing messages with fallback to new message
async def safe_edit_or_send(cbq, text, node_id=None, is_auto_transition=False, **kwargs):
    """
    Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ðµ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ñ fallback Ð½Ð° Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    ÐŸÑ€Ð¸ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ðµ ÑÑ€Ð°Ð·Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð±ÐµÐ· Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÐ¸ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
    """
    result = None
    user_id = None
    
    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ user_id Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ
    if hasattr(cbq, "from_user") and cbq.from_user:
        user_id = str(cbq.from_user.id)
    elif hasattr(cbq, "message") and cbq.message and hasattr(cbq.message, "chat"):
        user_id = str(cbq.message.chat.id)
    
    try:
        # ÐŸÑ€Ð¸ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ðµ ÑÑ€Ð°Ð·Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð±ÐµÐ· Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
        if is_auto_transition:
            logging.info(f"âš¡ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´: Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ")
            if hasattr(cbq, "message") and cbq.message:
                result = await cbq.message.answer(text, **kwargs)
            else:
                raise Exception("Cannot send message in auto-transition")
        else:
            # ÐŸÑ€Ð¾Ð±ÑƒÐµÐ¼ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
            if hasattr(cbq, "edit_text") and callable(getattr(cbq, "edit_text")):
                result = await cbq.edit_text(text, **kwargs)
            elif (hasattr(cbq, "message") and cbq.message):
                result = await cbq.message.edit_text(text, **kwargs)
            else:
                raise Exception("No valid edit method found")
    except Exception as e:
        # ÐŸÑ€Ð¸ Ð»ÑŽÐ±Ð¾Ð¹ Ð¾ÑˆÐ¸Ð±ÐºÐµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        if is_auto_transition:
            logging.info(f"âš¡ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´: {e}, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
        else:
            logging.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ: {e}, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð½Ð¾Ð²Ð¾Ðµ")
        if hasattr(cbq, "message") and cbq.message:
            result = await cbq.message.answer(text, **kwargs)
        else:
            logging.error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð¸ Ð¾Ñ‚Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ, Ð½Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
            raise
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    if result and user_id:
        message_data_obj = {"message_id": result.message_id if hasattr(result, "message_id") else None}
        
        # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð¸Ð· reply_markup
        if "reply_markup" in kwargs:
            try:
                reply_markup = kwargs["reply_markup"]
                buttons_data = []
                # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° inline ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
                if hasattr(reply_markup, "inline_keyboard"):
                    for row in reply_markup.inline_keyboard:
                        for btn in row:
                            button_info = {"text": btn.text}
                            if hasattr(btn, "url") and btn.url:
                                button_info["url"] = btn.url
                            if hasattr(btn, "callback_data") and btn.callback_data:
                                button_info["callback_data"] = btn.callback_data
                            buttons_data.append(button_info)
                    if buttons_data:
                        message_data_obj["buttons"] = buttons_data
                        message_data_obj["keyboard_type"] = "inline"
                # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° reply ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
                elif hasattr(reply_markup, "keyboard"):
                    for row in reply_markup.keyboard:
                        for btn in row:
                            button_info = {"text": btn.text}
                            if hasattr(btn, "request_contact") and btn.request_contact:
                                button_info["request_contact"] = True
                            if hasattr(btn, "request_location") and btn.request_location:
                                button_info["request_location"] = True
                            buttons_data.append(button_info)
                    if buttons_data:
                        message_data_obj["buttons"] = buttons_data
                        message_data_obj["keyboard_type"] = "reply"
            except Exception as btn_error:
                logging.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð² safe_edit_or_send: {btn_error}")
        
        await save_message_to_api(
            user_id=user_id,
            message_type="bot",
            message_text=text,
            node_id=node_id,
            message_data=message_data_obj
        )
    
    return result

# Ð¢Ð¾ÐºÐµÐ½ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð±Ð¾Ñ‚Ð° (Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ñƒ @BotFather)
BOT_TOKEN = "7713154819:AAGtj0O7RFLMM1rRhQhFJoWT9JikU5GiRoQ"

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ¾Ð¹ UTF-8
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

# Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð±Ð¾Ñ‚Ð° Ð¸ Ð´Ð¸ÑÐ¿ÐµÑ‚Ñ‡ÐµÑ€Ð°
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð°Ð´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² (Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ ÑÐ²Ð¾Ð¹ Telegram ID)
ADMIN_IDS = [123456789]  # Ð—Ð°Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ðµ ID Ð°Ð´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²

# API configuration Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
# ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ URL ÑÐµÑ€Ð²ÐµÑ€Ð° Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸
def get_api_base_url():
    # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ
    env_url = os.getenv("API_BASE_URL", os.getenv("REPLIT_DEV_DOMAIN"))
    if env_url:
        # Ð•ÑÐ»Ð¸ URL Ð½Ð°Ñ‡Ð¸Ð½Ð°ÐµÑ‚ÑÑ Ñ http/https, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÐºÐ°Ðº ÐµÑÑ‚ÑŒ
        if env_url.startswith(("http://", "https://")):
            # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… Ð°Ð´Ñ€ÐµÑÐ¾Ð² Ð²ÑÐµÐ³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ http, Ð° Ð½Ðµ https
            if "localhost" in env_url or "127.0.0.1" in env_url or "0.0.0.0" in env_url:
                if env_url.startswith("https://"):
                    # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ https Ð½Ð° http Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… Ð°Ð´Ñ€ÐµÑÐ¾Ð²
                    env_url = "http://" + env_url[8:]  # Ð£Ð±Ð¸Ñ€Ð°ÐµÐ¼ "https://" Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ "http://"
            return env_url
        # Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚, Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð»
        elif ":" in env_url:  # ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð¿Ð¾Ñ€Ñ‚
            return f"http://{env_url}"
        else:  # Ð´Ð¾Ð¼ÐµÐ½ Ð±ÐµÐ· Ð¿Ð¾Ñ€Ñ‚Ð°
            return f"https://{env_url}"
    
    # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ URL Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸
    try:
        import socket
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ IP-Ð°Ð´Ñ€ÐµÑ Ð¼Ð°ÑˆÐ¸Ð½Ñ‹
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
        
        # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð¿Ð¾Ñ€Ñ‚ Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ 5000 Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
        port = os.getenv("API_PORT", "5000")
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ IP Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¼
        if local_ip.startswith(("127.", "192.168.", "10.", "172.")) or local_ip == "::1":
            # Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… IP Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ localhost
            return f"http://localhost:{port}"
        else:
            # Ð”Ð»Ñ Ð²Ð½ÐµÑˆÐ½Ð¸Ñ… IP Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ IP-Ð°Ð´Ñ€ÐµÑ
            return f"http://{local_ip}:{port}"
    except:
        # Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ localhost Ñ Ð¿Ð¾Ñ€Ñ‚Ð¾Ð¼ Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ
        port = os.getenv("API_PORT", "5000")
        return f"http://localhost:{port}"

API_BASE_URL = get_api_base_url()
logging.info(f"ðŸ“¡ API Base URL Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½ ÐºÐ°Ðº: {API_BASE_URL}")
PROJECT_ID = int(os.getenv("PROJECT_ID", 7))  # ID Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ

# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‡ÐµÑ€ÐµÐ· API
async def save_message_to_api(user_id: str, message_type: str, message_text: str = None, node_id: str = None, message_data: dict = None):
    """Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‡ÐµÑ€ÐµÐ· API"""
    try:
        # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ URL Ð´Ð»Ñ API
        if API_BASE_URL.startswith("http"):
            api_url = f"{API_BASE_URL}/api/projects/{PROJECT_ID}/messages"
        else:
            api_url = f"https://{API_BASE_URL}/api/projects/{PROJECT_ID}/messages"
        
        payload = {
            "userId": str(user_id),
            "messageType": message_type,
            "messageText": message_text,
            "nodeId": node_id,
            "messageData": message_data or {}
        }
        
        logging.debug(f"ðŸ’¾ ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² API: {payload}")
        logging.debug(f"ðŸ“¡ API URL: {api_url}")
        
        # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð»Ð¸ SSL
        use_ssl = not (api_url.startswith("http://") or "localhost" in api_url or "127.0.0.1" in api_url or "0.0.0.0" in api_url)
        logging.debug(f"ðŸ”’ SSL Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð´Ð»Ñ URL {api_url}: {use_ssl}")
        # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: Ð”Ð»Ñ localhost Ð²ÑÐµÐ³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ssl=False, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸Ð·Ð±ÐµÐ¶Ð°Ñ‚ÑŒ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ SSL WRONG_VERSION_NUMBER
        if "localhost" in api_url or "127.0.0.1" in api_url or "0.0.0.0" in api_url:
            use_ssl = False
            logging.debug(f"ðŸ”“ SSL Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½ Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ URL: {api_url}")
        
        if use_ssl:
            # Ð”Ð»Ñ Ð²Ð½ÐµÑˆÐ½Ð¸Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
            connector = aiohttp.TCPConnector(ssl=True)
        else:
            # Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
            # Ð¯Ð²Ð½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ SSL Ð¸ ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð´Ð»Ñ Ð½ÐµÐ±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð³Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ
            import ssl
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            connector = aiohttp.TCPConnector(ssl=ssl_context)
        
        async with aiohttp.ClientSession(connector=connector) as session:
            async with session.post(api_url, json=payload, timeout=aiohttp.ClientTimeout(total=10)) as response:
                if response.status == 200:
                    logging.info(f"âœ… Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾: {message_type} Ð¾Ñ‚ {user_id}")
                    response_data = await response.json()
                    return response_data.get("data")  # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ñ id
                elif response.status == 429:
                    logging.warning(f"âš ï¸ Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÐµ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ: {user_id}, {message_type}")
                    return None
                else:
                    error_text = await response.text()
                    logging.error(f"âŒ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ: {response.status} - {error_text}")
                    logging.error(f"ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ñ‹Ð¹ payload: {payload}")
                    return None
    except aiohttp.ClientConnectorError as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº API: {e}")
    except asyncio.TimeoutError as e:
        logging.error(f"Ð¢Ð°Ð¹Ð¼Ð°ÑƒÑ‚ Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¸ Ðº API: {e}")
    except Exception as e:
        logging.error(f"ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ: {type(e).__name__}: {e}")
    return None

# Middleware Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
async def message_logging_middleware(handler, event: types.Message, data: dict):
    """Middleware Ð´Ð»Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ð³Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹"""
    try:
        # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð²Ñ…Ð¾Ð´ÑÑ‰ÐµÐµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
        user_id = str(event.from_user.id)
        message_text = event.text or event.caption or "[Ð¼ÐµÐ´Ð¸Ð°]"
        message_data = {"message_id": event.message_id}
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ñ„Ð¾Ñ‚Ð¾
        photo_file_id = None
        if event.photo:
            # Ð‘ÐµÑ€ÐµÐ¼ Ñ„Ð¾Ñ‚Ð¾ Ð½Ð°Ð¸Ð±Ð¾Ð»ÑŒÑˆÐµÐ³Ð¾ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° (Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐµ Ð² ÑÐ¿Ð¸ÑÐºÐµ)
            largest_photo = event.photo[-1]
            photo_file_id = largest_photo.file_id
            message_data["photo"] = {
                "file_id": largest_photo.file_id,
                "file_unique_id": largest_photo.file_unique_id,
                "width": largest_photo.width,
                "height": largest_photo.height,
                "file_size": largest_photo.file_size if hasattr(largest_photo, "file_size") else None
            }
            if not message_text or message_text == "[Ð¼ÐµÐ´Ð¸Ð°]":
                message_text = "[Ð¤Ð¾Ñ‚Ð¾]"
        
        # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
        saved_message = await save_message_to_api(
            user_id=user_id,
            message_type="user",
            message_text=message_text,
            message_data=message_data
        )
        
        # Ð•ÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ñ„Ð¾Ñ‚Ð¾ Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾, Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¼ÐµÐ´Ð¸Ð°
        if photo_file_id and saved_message and "id" in saved_message:
            try:
                if API_BASE_URL.startswith("http://") or API_BASE_URL.startswith("https://"):
                    media_api_url = f"{API_BASE_URL}/api/projects/{PROJECT_ID}/media/register-telegram-photo"
                else:
                    media_api_url = f"https://{API_BASE_URL}/api/projects/{PROJECT_ID}/media/register-telegram-photo"
                
                media_payload = {
                    "messageId": saved_message["id"],
                    "fileId": photo_file_id,
                    "botToken": BOT_TOKEN,
                    "mediaType": "photo"
                }
                
                # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð»Ð¸ SSL Ð´Ð»Ñ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²
                use_ssl_media = not (media_api_url.startswith("http://") or "localhost" in media_api_url or "127.0.0.1" in media_api_url or "0.0.0.0" in media_api_url)
                logging.debug(f"ðŸ”’ SSL Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð´Ð»Ñ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° {media_api_url}: {use_ssl_media}")
                # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: Ð”Ð»Ñ localhost Ð²ÑÐµÐ³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ssl=False, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸Ð·Ð±ÐµÐ¶Ð°Ñ‚ÑŒ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ SSL WRONG_VERSION_NUMBER
                if "localhost" in media_api_url or "127.0.0.1" in media_api_url or "0.0.0.0" in media_api_url:
                    use_ssl_media = False
                    logging.debug(f"ðŸ”“ SSL Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½ Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: {media_api_url}")
                
                if use_ssl_media:
                    # Ð”Ð»Ñ Ð²Ð½ÐµÑˆÐ½Ð¸Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
                    connector = aiohttp.TCPConnector(ssl=True)
                else:
                    # Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
                    # Ð¯Ð²Ð½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ SSL Ð¸ ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð´Ð»Ñ Ð½ÐµÐ±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð³Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ
                    import ssl
                    ssl_context = ssl.create_default_context()
                    ssl_context.check_hostname = False
                    ssl_context.verify_mode = ssl.CERT_NONE
                    connector = aiohttp.TCPConnector(ssl=ssl_context)
                
                async with aiohttp.ClientSession(connector=connector) as session:
                    async with session.post(media_api_url, json=media_payload, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            message_id = saved_message.get("id")
                            logging.info(f"âœ… ÐœÐµÐ´Ð¸Ð° Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð´Ð»Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ {message_id}")
                        else:
                            error_text = await response.text()
                            logging.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¼ÐµÐ´Ð¸Ð°: {response.status} - {error_text}")
            except Exception as media_error:
                logging.warning(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸ Ð¼ÐµÐ´Ð¸Ð°: {media_error}")
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² middleware ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹: {e}")
    
    # ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ
    return await handler(event, data)

# ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¸ÑÑ…Ð¾Ð´ÑÑ‰Ð¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
original_send_message = bot.send_message
async def send_message_with_logging(chat_id, text, *args, node_id=None, **kwargs):
    """ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ bot.send_message Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼"""
    result = await original_send_message(chat_id, text, *args, **kwargs)
    
    # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ ÐºÐ½Ð¾Ð¿ÐºÐ°Ñ… Ð¸Ð· reply_markup
    message_data_obj = {"message_id": result.message_id if result else None}
    if "reply_markup" in kwargs:
        try:
            reply_markup = kwargs["reply_markup"]
            buttons_data = []
            # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° inline ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
            if hasattr(reply_markup, "inline_keyboard"):
                for row in reply_markup.inline_keyboard:
                    for btn in row:
                        button_info = {"text": btn.text}
                        if hasattr(btn, "url") and btn.url:
                            button_info["url"] = btn.url
                        if hasattr(btn, "callback_data") and btn.callback_data:
                            button_info["callback_data"] = btn.callback_data
                        buttons_data.append(button_info)
                if buttons_data:
                    message_data_obj["buttons"] = buttons_data
                    message_data_obj["keyboard_type"] = "inline"
            # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° reply ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
            elif hasattr(reply_markup, "keyboard"):
                for row in reply_markup.keyboard:
                    for btn in row:
                        button_info = {"text": btn.text}
                        if hasattr(btn, "request_contact") and btn.request_contact:
                            button_info["request_contact"] = True
                        if hasattr(btn, "request_location") and btn.request_location:
                            button_info["request_location"] = True
                        buttons_data.append(button_info)
                if buttons_data:
                    message_data_obj["buttons"] = buttons_data
                    message_data_obj["keyboard_type"] = "reply"
        except Exception as e:
            logging.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ ÐºÐ½Ð¾Ð¿ÐºÐ¸: {e}")
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð´Ð»Ñ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ð¸ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸
    await save_message_to_api(
        user_id=str(chat_id),
        message_type="bot",
        message_text=text,
        node_id=node_id,
        message_data=message_data_obj
    )
    return result

bot.send_message = send_message_with_logging

# ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ message.answer Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼
original_answer = types.Message.answer
async def answer_with_logging(self, text, *args, node_id=None, **kwargs):
    """ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ message.answer Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼"""
    result = await original_answer(self, text, *args, **kwargs)
    
    # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ ÐºÐ½Ð¾Ð¿ÐºÐ°Ñ… Ð¸Ð· reply_markup
    message_data_obj = {"message_id": result.message_id if result else None}
    if "reply_markup" in kwargs:
        try:
            reply_markup = kwargs["reply_markup"]
            buttons_data = []
            # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° inline ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
            if hasattr(reply_markup, "inline_keyboard"):
                for row in reply_markup.inline_keyboard:
                    for btn in row:
                        button_info = {"text": btn.text}
                        if hasattr(btn, "url") and btn.url:
                            button_info["url"] = btn.url
                        if hasattr(btn, "callback_data") and btn.callback_data:
                            button_info["callback_data"] = btn.callback_data
                        buttons_data.append(button_info)
                if buttons_data:
                    message_data_obj["buttons"] = buttons_data
                    message_data_obj["keyboard_type"] = "inline"
            # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° reply ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñ‹
            elif hasattr(reply_markup, "keyboard"):
                for row in reply_markup.keyboard:
                    for btn in row:
                        button_info = {"text": btn.text}
                        if hasattr(btn, "request_contact") and btn.request_contact:
                            button_info["request_contact"] = True
                        if hasattr(btn, "request_location") and btn.request_location:
                            button_info["request_location"] = True
                        buttons_data.append(button_info)
                if buttons_data:
                    message_data_obj["buttons"] = buttons_data
                    message_data_obj["keyboard_type"] = "reply"
        except Exception as e:
            logging.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ ÐºÐ½Ð¾Ð¿ÐºÐ¸: {e}")
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð´Ð»Ñ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ð¸ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸
    await save_message_to_api(
        user_id=str(self.chat.id),
        message_type="bot",
        message_text=text if isinstance(text, str) else str(text),
        node_id=node_id,
        message_data=message_data_obj
    )
    return result

types.Message.answer = answer_with_logging

# ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ bot.send_photo Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼
original_send_photo = bot.send_photo
async def send_photo_with_logging(chat_id, photo, *args, caption=None, node_id=None, **kwargs):
    """ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ bot.send_photo Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸ÐµÐ¼"""
    result = await original_send_photo(chat_id, photo, *args, caption=caption, **kwargs)
    
    # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ message_data Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¾ Ñ„Ð¾Ñ‚Ð¾
    message_data_obj = {"message_id": result.message_id if result else None}
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ„Ð¾Ñ‚Ð¾
    if result and hasattr(result, "photo") and result.photo:
        largest_photo = result.photo[-1]
        message_data_obj["photo"] = {
            "file_id": largest_photo.file_id,
            "file_unique_id": largest_photo.file_unique_id,
            "width": largest_photo.width,
            "height": largest_photo.height
        }
    # Ð•ÑÐ»Ð¸ photo ÑÑ‚Ð¾ ÑÑ‚Ñ€Ð¾ÐºÐ° (URL), ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ URL
    elif isinstance(photo, str):
        message_data_obj["photo_url"] = photo
    
    # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ ÐºÐ½Ð¾Ð¿ÐºÐ°Ñ… Ð¸Ð· reply_markup
    if "reply_markup" in kwargs:
        try:
            reply_markup = kwargs["reply_markup"]
            buttons_data = []
            if hasattr(reply_markup, "inline_keyboard"):
                for row in reply_markup.inline_keyboard:
                    for btn in row:
                        button_info = {"text": btn.text}
                        if hasattr(btn, "url") and btn.url:
                            button_info["url"] = btn.url
                        if hasattr(btn, "callback_data") and btn.callback_data:
                            button_info["callback_data"] = btn.callback_data
                        buttons_data.append(button_info)
                if buttons_data:
                    message_data_obj["buttons"] = buttons_data
                    message_data_obj["keyboard_type"] = "inline"
        except Exception as e:
            logging.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð¸Ð· send_photo: {e}")
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    saved_message = await save_message_to_api(
        user_id=str(chat_id),
        message_type="bot",
        message_text=caption or "[Ð¤Ð¾Ñ‚Ð¾]",
        node_id=node_id,
        message_data=message_data_obj
    )
    
    # Ð•ÑÐ»Ð¸ Ñ„Ð¾Ñ‚Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾ Ð¾Ñ‚ Ð±Ð¾Ñ‚Ð° Ñ file_id, Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¼ÐµÐ´Ð¸Ð°
    if result and hasattr(result, "photo") and result.photo and saved_message and "id" in saved_message:
        try:
            largest_photo = result.photo[-1]
            if API_BASE_URL.startswith("http://") or API_BASE_URL.startswith("https://"):
                media_api_url = f"{API_BASE_URL}/api/projects/{PROJECT_ID}/media/register-telegram-photo"
            else:
                media_api_url = f"https://{API_BASE_URL}/api/projects/{PROJECT_ID}/media/register-telegram-photo"
            
            media_payload = {
                "messageId": saved_message["id"],
                "fileId": largest_photo.file_id,
                "botToken": BOT_TOKEN,
                "mediaType": "photo"
            }
            
            # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð»Ð¸ SSL Ð´Ð»Ñ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²
            use_ssl_media = not (media_api_url.startswith("http://") or "localhost" in media_api_url or "127.0.0.1" in media_api_url or "0.0.0.0" in media_api_url)
            logging.debug(f"ðŸ”’ SSL Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð´Ð»Ñ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° {media_api_url}: {use_ssl_media}")
            # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: Ð”Ð»Ñ localhost Ð²ÑÐµÐ³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ssl=False, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸Ð·Ð±ÐµÐ¶Ð°Ñ‚ÑŒ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ SSL WRONG_VERSION_NUMBER
            if "localhost" in media_api_url or "127.0.0.1" in media_api_url or "0.0.0.0" in media_api_url:
                use_ssl_media = False
                logging.debug(f"ðŸ”“ SSL Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½ Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð°-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: {media_api_url}")
            
            if use_ssl_media:
                # Ð”Ð»Ñ Ð²Ð½ÐµÑˆÐ½Ð¸Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
                connector = aiohttp.TCPConnector(ssl=True)
            else:
                # Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ SSL-ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚
                # Ð¯Ð²Ð½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ SSL Ð¸ ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð´Ð»Ñ Ð½ÐµÐ±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð³Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ
                import ssl
                ssl_context = ssl.create_default_context()
                ssl_context.check_hostname = False
                ssl_context.verify_mode = ssl.CERT_NONE
                connector = aiohttp.TCPConnector(ssl=ssl_context)
            
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.post(media_api_url, json=media_payload, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        bot_message_id = saved_message.get("id")
                        logging.info(f"âœ… ÐœÐµÐ´Ð¸Ð° Ð±Ð¾Ñ‚Ð° Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð´Ð»Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ {bot_message_id}")
                    else:
                        error_text = await response.text()
                        logging.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¼ÐµÐ´Ð¸Ð° Ð±Ð¾Ñ‚Ð°: {response.status} - {error_text}")
        except Exception as media_error:
            logging.warning(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸ Ð¼ÐµÐ´Ð¸Ð° Ð±Ð¾Ñ‚Ð°: {media_error}")
    
    return result

bot.send_photo = send_photo_with_logging

# Ð¥Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ (Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ)
user_data = {}

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
DATABASE_URL = os.getenv("DATABASE_URL")

# ÐŸÑƒÐ» ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
db_pool = None


# Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
async def init_database():
    """Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ñ‚Ð°Ð±Ð»Ð¸Ñ†"""
    global db_pool
    try:
        db_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñƒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ ÐµÑÐ»Ð¸ ÐµÑ‘ Ð½ÐµÑ‚
        async with db_pool.acquire() as conn:
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS bot_users (
                    user_id BIGINT PRIMARY KEY,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    registered_at TIMESTAMP DEFAULT NOW(),
                    last_interaction TIMESTAMP DEFAULT NOW(),
                    interaction_count INTEGER DEFAULT 0,
                    user_data JSONB DEFAULT '{}',
                    is_active BOOLEAN DEFAULT TRUE
                );
            """)
            # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ ÐµÑÐ»Ð¸ ÐµÑ‘ Ð½ÐµÑ‚
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS bot_messages (
                    id SERIAL PRIMARY KEY,
                    project_id INTEGER,
                    user_id TEXT NOT NULL,
                    message_type TEXT NOT NULL,
                    message_text TEXT,
                    message_data JSONB,
                    node_id TEXT,
                    created_at TIMESTAMP DEFAULT NOW()
                );
            """)
        logging.info("âœ… Ð‘Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°")
    except Exception as e:
        logging.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ðº Ð‘Ð”: {e}. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ.")
        db_pool = None

def get_moscow_time():
    """Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ‚ÐµÐºÑƒÑ‰ÐµÐµ Ð²Ñ€ÐµÐ¼Ñ Ð² Ð¼Ð¾ÑÐºÐ¾Ð²ÑÐºÐ¾Ð¼ Ñ‡Ð°ÑÐ¾Ð²Ð¾Ð¼ Ð¿Ð¾ÑÑÐµ"""
    from datetime import datetime, timezone, timedelta
    moscow_tz = timezone(timedelta(hours=3))
    return datetime.now(moscow_tz).isoformat()

def replace_variables_in_text(text_content, variables_dict):
    """Ð—Ð°Ð¼ÐµÐ½ÑÐµÑ‚ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð° {variable_name} Ð² Ñ‚ÐµÐºÑÑ‚Ðµ Ð½Ð° Ð¸Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ
    
    Args:
        text_content (str): Ð¢ÐµÐºÑÑ‚ Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Ð´Ð»Ñ Ð·Ð°Ð¼ÐµÐ½Ñ‹
        variables_dict (dict): Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    
    Returns:
        str: Ð¢ÐµÐºÑÑ‚ Ñ Ð·Ð°Ð¼ÐµÐ½ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¼Ð¸
    """
    if not text_content or not variables_dict:
        return text_content
    
    # ÐŸÑ€Ð¾Ñ…Ð¾Ð´Ð¸Ð¼ Ð¿Ð¾ Ð²ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    for var_name, var_data in variables_dict.items():
        placeholder = "{" + var_name + "}"
        if placeholder in text_content:
            # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹
            if isinstance(var_data, dict) and "value" in var_data:
                var_value = str(var_data["value"]) if var_data["value"] is not None else var_name
            elif var_data is not None:
                var_value = str(var_data)
            else:
                var_value = var_name  # ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¸Ð¼Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ ÐµÑÐ»Ð¸ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð½ÐµÑ‚
            
            # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð½Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
            text_content = text_content.replace(placeholder, var_value)
            logging.debug(f"ðŸ”„ Ð—Ð°Ð¼ÐµÐ½ÐµÐ½Ð° Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ {placeholder} Ð½Ð° '{var_value}'")
    
    return text_content
def init_user_variables(user_id, user_obj):
    """Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· Telegram API
    
    Args:
        user_id (int): ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Telegram
        user_obj: ÐžÐ±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· aiogram (message.from_user Ð¸Ð»Ð¸ callback_query.from_user)
    
    Returns:
        str: Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ (Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚: first_name > username > "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ")
    """
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data:
        user_data[user_id] = {}
    
    # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¸Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Telegram API
    username = user_obj.username if hasattr(user_obj, "username") else None
    first_name = user_obj.first_name if hasattr(user_obj, "first_name") else None
    last_name = user_obj.last_name if hasattr(user_obj, "last_name") else None
    
    # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÐ¼Ð¾Ðµ Ð¸Ð¼Ñ Ð¿Ð¾ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ñƒ
    user_name = first_name or username or "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð²ÑÐµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð² Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
    user_data[user_id]["user_name"] = user_name
    user_data[user_id]["first_name"] = first_name
    user_data[user_id]["last_name"] = last_name
    user_data[user_id]["username"] = username
    
    # Ð›Ð¾Ð³Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑŽ Ð´Ð»Ñ Ð¾Ñ‚Ð»Ð°Ð´ÐºÐ¸
    logging.info(f"âœ… Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {user_id}: user_name='{user_name}', first_name='{first_name}', username='{username}'")
    
    return user_name
async def save_user_to_db(user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None):
    """Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
    if not db_pool:
        return False
    try:
        async with db_pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO bot_users (user_id, username, first_name, last_name)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    first_name = EXCLUDED.first_name,
                    last_name = EXCLUDED.last_name,
                    last_interaction = NOW(),
                    interaction_count = bot_users.interaction_count + 1
            """, user_id, username, first_name, last_name)
        return True
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð‘Ð”: {e}")
        return False

async def get_user_from_db(user_id: int):
    """ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
    if not db_pool:
        return None
    try:
        async with db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM bot_users WHERE user_id = $1", user_id)
            if row:
                # ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÐ¼ Record Ð² ÑÐ»Ð¾Ð²Ð°Ñ€ÑŒ
                row_dict = {key: row[key] for key in row.keys()}
                # Ð•ÑÐ»Ð¸ ÐµÑÑ‚ÑŒ user_data, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ ÐµÐ³Ð¾ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ
                if "user_data" in row_dict and row_dict["user_data"]:
                    user_data = row_dict["user_data"]
                    if isinstance(user_data, str):
                        try:
                            import json
                            return json.loads(user_data)
                        except (json.JSONDecodeError, TypeError):
                            return {}
                    elif isinstance(user_data, dict):
                        return user_data
                    else:
                        return {}
                # Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚ user_data, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¿Ð¾Ð»Ð½ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ
                return row_dict
        return None
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· Ð‘Ð”: {e}")
        return None

async def get_user_data_from_db(user_id: int, data_key: str):
    """ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¸Ð· Ð¿Ð¾Ð»Ñ user_data Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ"""
    if not db_pool:
        return None
    try:
        async with db_pool.acquire() as conn:
            # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ->> Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»Ñ JSONB ÐºÐ°Ðº Ñ‚ÐµÐºÑÑ‚Ð°
            value = await conn.fetchval(
                "SELECT user_data ->> $2 FROM bot_users WHERE user_id = $1",
                user_id,
                data_key
            )
            return value
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· Ð‘Ð”: {e}")
        return None

# ÐÐ»Ð¸Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ callback Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¾Ð²
async def handle_command_start(message):
    """ÐÐ»Ð¸Ð°Ñ Ð´Ð»Ñ start_handler, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð² callback Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°Ñ…"""
    await start_handler(message)

async def handle_command_settings(message):
    """ÐÐ»Ð¸Ð°Ñ Ð´Ð»Ñ settings_handler, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð² callback Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°Ñ…"""
    await settings_handler(message)

async def update_user_data_in_db(user_id: int, data_key: str, data_value):
    """ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
    if not db_pool:
        return False
    try:
        import json
        async with db_pool.acquire() as conn:
            # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° ÑÐ¾Ð·Ð´Ð°Ñ‘Ð¼ Ð¸Ð»Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ
            await conn.execute("""
                INSERT INTO bot_users (user_id) 
                VALUES ($1) 
                ON CONFLICT (user_id) DO NOTHING
            """, user_id)
            
            # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            update_data = {data_key: data_value}
            await conn.execute("""
                UPDATE bot_users 
                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,
                    last_interaction = NOW()
                WHERE user_id = $1
            """, user_id, json.dumps(update_data))
        return True
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ: {e}")
        return False

async def save_user_data_to_db(user_id: int, data_key: str, data_value):
    """ÐÐ»Ð¸Ð°Ñ Ð´Ð»Ñ update_user_data_in_db Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ð¹ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸"""
    return await update_user_data_in_db(user_id, data_key, data_value)

async def update_user_variable_in_db(user_id: int, variable_name: str, variable_value: str):
    """Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
    if not db_pool:
        return False
    try:
        import json
        async with db_pool.acquire() as conn:
            # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° ÑÐ¾Ð·Ð´Ð°Ñ‘Ð¼ Ð¸Ð»Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ
            await conn.execute("""
                INSERT INTO bot_users (user_id) 
                VALUES ($1) 
                ON CONFLICT (user_id) DO NOTHING
            """, user_id)
            
            # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            update_data = {variable_name: variable_value}
            await conn.execute("""
                UPDATE bot_users 
                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,
                    last_interaction = NOW()
                WHERE user_id = $1
            """, user_id, json.dumps(update_data))
        return True
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ: {e}")
        return False

async def log_message(user_id: int, message_type: str, message_text: str = None, message_data: dict = None, node_id: str = None):
    """Ð›Ð¾Ð³Ð¸Ñ€ÑƒÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…"""
    if not db_pool:
        return False
    try:
        import json
        async with db_pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO bot_messages (user_id, message_type, message_text, message_data, node_id)
                VALUES ($1, $2, $3, $4, $5)
            """, str(user_id), message_type, message_text, json.dumps(message_data) if message_data else None, node_id)
        return True
    except Exception as e:
        logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ: {e}")
        return False


# Ð£Ñ‚Ð¸Ð»Ð¸Ñ‚Ð°Ñ€Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
from aiogram import types

async def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS

async def is_private_chat(message: types.Message) -> bool:
    return message.chat.type == "private"

async def check_auth(user_id: int) -> bool:
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð‘Ð” Ð¸Ð»Ð¸ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ
    if db_pool:
        user = await get_user_from_db(user_id)
        return user is not None
    return user_id in user_data


# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð¼ÐµÐ½ÑŽ ÐºÐ¾Ð¼Ð°Ð½Ð´
# Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÑƒ Ð¼ÐµÐ½ÑŽ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð´Ð»Ñ BotFather
async def set_bot_commands():
    commands = [
        # ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° start - Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ð¾Ñ‚Ð°
        BotCommand(command="start", description="Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ð¾Ñ‚Ð°"),
        # ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° settings - ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°
        BotCommand(command="settings", description="ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°"),
    ]
# Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð´Ð»Ñ Ð±Ð¾Ñ‚Ð°
    await bot.set_my_commands(commands)


# @@NODE_START:start@@

@dp.message(CommandStart())
async def start_handler(message: types.Message):

    # Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name
    last_name = message.from_user.last_name
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    user_name = init_user_variables(user_id, message.from_user)
    await update_user_data_in_db(user_id, "user_name", user_name)
    await update_user_data_in_db(user_id, "first_name", first_name)
    await update_user_data_in_db(user_id, "last_name", last_name)
    await update_user_data_in_db(user_id, "username", username)
    
    # Ð ÐµÐ·ÐµÑ€Ð²Ð½Ð¾Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð² Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ
    if not saved_to_db:
        user_data[user_id] = {
            "username": username,
            "first_name": first_name,
            "last_name": last_name,
            "user_name": user_name,
            "registered_at": message.date
        }
        logging.info(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {user_id} ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½ Ð² Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ")
    else:
        logging.info(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {user_id} ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…")

    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ imageUrl Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ image_url_start
    user_data[user_id]["image_url_start"] = "https://i.pinimg.com/originals/24/ac/ef/24acef8b3a6a45d7239480bcc4ff0193.jpg"
    await update_user_data_in_db(user_id, "image_url_start", "https://i.pinimg.com/originals/24/ac/ef/24acef8b3a6a45d7239480bcc4ff0193.jpg")
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    text = "ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð²Ð°Ñˆ Ð½Ð¾Ð²Ñ‹Ð¹ Ð±Ð¾Ñ‚. ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ /help Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð¸."
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    text = replace_variables_in_text(text, user_vars)
    
    has_regular_buttons = False
    has_input_collection = False
    logging.info(f"DEBUG: generateKeyboard Ð´Ð»Ñ ÑƒÐ·Ð»Ð° start - hasRegularButtons={has_regular_buttons}, hasInputCollection={has_input_collection}, collectUserInput=undefined, enableTextInput=undefined, enablePhotoInput=undefined, enableVideoInput=undefined, enableAudioInput=undefined, enableDocumentInput=undefined")
    # DEBUG: Ð£Ð·ÐµÐ» start - hasRegularButtons=False, hasInputCollection=False
    logging.info(f"DEBUG: Ð£Ð·ÐµÐ» start Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ½Ð¾Ð¿Ð¾Ðº - keyboardType=none, buttons=0")
    await message.answer(text)

    # ÐÐ’Ð¢ÐžÐŸÐ•Ð Ð•Ð¥ÐžÐ”: ÐŸÐµÑ€ÐµÑ…Ð¾Ð´Ð¸Ð¼ Ðº ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ¼Ñƒ ÑƒÐ·Ð»Ñƒ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ (ÐµÑÐ»Ð¸ collectUserInput!=true)
    logging.info(f"âš¡ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð¾Ñ‚ ÑƒÐ·Ð»Ð° start Ðº ÑƒÐ·Ð»Ñƒ DDmAXMnH_Dyd8T7J-wm9S")
    # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ callback_query Ð¾Ð±ÑŠÐµÐºÑ‚ Ð´Ð»Ñ Ð²Ñ‹Ð·Ð¾Ð²Ð° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°
    from aiogram.types import CallbackQuery
    temp_callback = CallbackQuery(
        id="auto_transition",
        from_user=message.from_user,
        data="DDmAXMnH_Dyd8T7J-wm9S",
        chat_instance=str(message.chat.id),
        message=message
    )
    await handle_callback_DDmAXMnH_Dyd8T7J_wm9S(temp_callback)
    logging.info(f"âœ… ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½: start -> DDmAXMnH_Dyd8T7J-wm9S")
# @@NODE_END:start@@

# @@NODE_START:DDmAXMnH_Dyd8T7J-wm9S@@
# @@NODE_END:DDmAXMnH_Dyd8T7J-wm9S@@

# @@NODE_START:2pmaMDNyVr3oVOHL98LwP@@

@dp.message(Command("settings"))
async def settings_handler(message: types.Message):
    logging.info(f"ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /settings Ð²Ñ‹Ð·Ð²Ð°Ð½Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼ {message.from_user.id}")
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name
    last_name = message.from_user.last_name
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)
    
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    user_name = init_user_variables(user_id, message.from_user)
    await update_user_data_in_db(user_id, "user_name", user_name)
    await update_user_data_in_db(user_id, "first_name", first_name)
    await update_user_data_in_db(user_id, "last_name", last_name)
    await update_user_data_in_db(user_id, "username", username)
    
    # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ ÐºÐ¾Ð¼Ð°Ð½Ð´ Ð² Ð‘Ð”
    if saved_to_db:
        await update_user_data_in_db(user_id, "command_settings", datetime.now().isoformat())
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð² Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ
    user_name = init_user_variables(user_id, message.from_user)
    
    if "commands_used" not in user_data[user_id]:
        user_data[user_id]["commands_used"] = {}
    user_data[user_id]["commands_used"]["/settings"] = user_data[user_id]["commands_used"].get("/settings", 0) + 1

    text = "âš™ï¸ ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°:"
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ documentUrl Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ document_url_2pmaMDNyVr3oVOHL98LwP
    user_data[user_id]["document_url_2pmaMDNyVr3oVOHL98LwP"] = "â€‹https://img.freepik.com/free-photo/cartoon-style-hugging-day-celebration_23-2151033271.jpg?semt=ais_hybrid&w=740"
    await update_user_data_in_db(user_id, "document_url_2pmaMDNyVr3oVOHL98LwP", "â€‹https://img.freepik.com/free-photo/cartoon-style-hugging-day-celebration_23-2151033271.jpg?semt=ais_hybrid&w=740")
    
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    text = replace_variables_in_text(text, user_vars)
    
    has_regular_buttons = False
    has_input_collection = False
    logging.info(f"DEBUG: generateKeyboard Ð´Ð»Ñ ÑƒÐ·Ð»Ð° 2pmaMDNyVr3oVOHL98LwP - hasRegularButtons={has_regular_buttons}, hasInputCollection={has_input_collection}, collectUserInput=undefined, enableTextInput=undefined, enablePhotoInput=undefined, enableVideoInput=undefined, enableAudioInput=undefined, enableDocumentInput=undefined")
    # DEBUG: Ð£Ð·ÐµÐ» 2pmaMDNyVr3oVOHL98LwP - hasRegularButtons=False, hasInputCollection=False
    logging.info(f"DEBUG: Ð£Ð·ÐµÐ» 2pmaMDNyVr3oVOHL98LwP Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ½Ð¾Ð¿Ð¾Ðº - keyboardType=none, buttons=2")
    await message.answer(text, parse_mode=ParseMode.MARKDOWN)
# @@NODE_END:2pmaMDNyVr3oVOHL98LwP@@

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð¾Ð²

@dp.callback_query(lambda c: c.data == "DDmAXMnH_Dyd8T7J-wm9S" or c.data.startswith("DDmAXMnH_Dyd8T7J-wm9S_btn_") or c.data == "done_d8T7J-wm9S")
async def handle_callback_DDmAXMnH_Dyd8T7J_wm9S(callback_query: types.CallbackQuery):
    # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· callback_query
    try:
        user_id = callback_query.from_user.id
        callback_data = callback_query.data
        logging.info(f"ðŸ”µ Ð’Ñ‹Ð·Ð²Ð°Ð½ callback handler: handle_callback_DDmAXMnH_Dyd8T7J_wm9S Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {user_id}")
    except Exception as e:
        logging.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ðº callback_query Ð² handle_callback_DDmAXMnH_Dyd8T7J_wm9S: {e}")
        return
    
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ„Ð»Ð°Ð³ hideAfterClick Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿Ð¾Ðº
    
    
    # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ñ‚ÑŒ Ð½Ð° callback (Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÑƒ ÐµÑÐ»Ð¸ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½)
    try:
        await callback_query.answer()
    except Exception:
        pass  # Ð˜Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÑƒ ÐµÑÐ»Ð¸ callback ÑƒÐ¶Ðµ Ð±Ñ‹Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½ (Ð¿Ñ€Ð¸ Ð²Ñ‹Ð·Ð¾Ð²Ðµ Ñ‡ÐµÑ€ÐµÐ· Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´)
    
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    user_name = init_user_variables(user_id, callback_query.from_user)
    
    # Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ñ„Ð»Ð°Ð³ collectUserInput Ð´Ð»Ñ ÑƒÐ·Ð»Ð° DDmAXMnH_Dyd8T7J-wm9S
    if user_id not in user_data:
        user_data[user_id] = {}
    user_data[user_id]["collectUserInput_DDmAXMnH_Dyd8T7J-wm9S"] = False
    logging.info(f"â„¹ï¸ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ„Ð»Ð°Ð³ collectUserInput Ð´Ð»Ñ ÑƒÐ·Ð»Ð° DDmAXMnH_Dyd8T7J-wm9S: false")
    
    # ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ ÑƒÐ·ÐµÐ» DDmAXMnH_Dyd8T7J-wm9S: DDmAXMnH_Dyd8T7J-wm9S
    text = "ÐÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ"
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ imageUrl Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ image_url_DDmAXMnH_Dyd8T7J-wm9S
    user_data[user_id]["image_url_DDmAXMnH_Dyd8T7J-wm9S"] = "https://i.pinimg.com/originals/22/ea/6c/22ea6c80800709ebd03e3ba2c0c12499.jpg"
    await update_user_data_in_db(user_id, "image_url_DDmAXMnH_Dyd8T7J-wm9S", "https://i.pinimg.com/originals/22/ea/6c/22ea6c80800709ebd03e3ba2c0c12499.jpg")
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    keyboard = None
    
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ ÑƒÑÐ»Ð¾Ð²Ð½Ð°Ñ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ð° Ð´Ð»Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ conditional_keyboard, ÐµÑÐ»Ð¸ Ð¾Ð½Ð° Ð½Ðµ Ð±Ñ‹Ð»Ð° Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð°
    if "conditional_keyboard" not in locals():
        conditional_keyboard = None
    user_id = callback_query.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if "conditional_keyboard" in locals() and conditional_keyboard is not None:
        keyboard = conditional_keyboard
        user_data[user_id]["_has_conditional_keyboard"] = True
        logging.info("âœ… Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÑƒÑÐ»Ð¾Ð²Ð½ÑƒÑŽ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñƒ Ð´Ð»Ñ Ð½Ð°Ð²Ð¸Ð³Ð°Ñ†Ð¸Ð¸")
    else:
        user_data[user_id]["_has_conditional_keyboard"] = False
    
    # ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ (Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¾Ð¹ Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð°)
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð° Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ image_url_DDmAXMnH_Dyd8T7J-wm9S
    attached_media = None
    if user_vars and "image_url_DDmAXMnH_Dyd8T7J-wm9S" in user_vars:
        media_data = user_vars["image_url_DDmAXMnH_Dyd8T7J-wm9S"]
        if isinstance(media_data, dict) and "value" in media_data:
            attached_media = media_data["value"]
        elif isinstance(media_data, str):
            attached_media = media_data
    else:
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð¼ÐµÐ´Ð¸Ð° Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
        user_id = callback_query.from_user.id
        user_node_vars = user_data.get(user_id, {})
        if "image_url_DDmAXMnH_Dyd8T7J-wm9S" in user_node_vars:
            attached_media = user_node_vars["image_url_DDmAXMnH_Dyd8T7J-wm9S"]
    
    # Ð•ÑÐ»Ð¸ Ð¼ÐµÐ´Ð¸Ð° Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ñ Ð¼ÐµÐ´Ð¸Ð°, Ð¸Ð½Ð°Ñ‡Ðµ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    if attached_media and str(attached_media).strip():
        logging.info(f"ðŸ“Ž ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° photo Ð¼ÐµÐ´Ð¸Ð° Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ image_url_DDmAXMnH_Dyd8T7J-wm9S: {attached_media}")
        try:
            # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð² Ñ‚ÐµÐºÑÑ‚Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¾Ð¹ Ð¼ÐµÐ´Ð¸Ð°
            processed_caption = replace_variables_in_text(text, user_vars)
            await bot.send_photo(callback_query.from_user.id, attached_media, caption=processed_caption, reply_markup=keyboard)
        except Exception as e:
            logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ photo: {e}")
            # Fallback Ð½Ð° Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ
            await safe_edit_or_send(callback_query, text, node_id="DDmAXMnH_Dyd8T7J-wm9S", reply_markup=keyboard if keyboard is not None else None)
    else:
        # ÐœÐµÐ´Ð¸Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        logging.info(f"ðŸ“ ÐœÐµÐ´Ð¸Ð° image_url_DDmAXMnH_Dyd8T7J-wm9S Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
        # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð² Ñ‚ÐµÐºÑÑ‚Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¾Ð¹
        processed_text = replace_variables_in_text(text, user_vars)
        if False:
            # Ð£Ð·ÐµÐ» Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´, Ð½Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
            logging.info(f"â„¹ï¸ Ð£Ð·ÐµÐ» DDmAXMnH_Dyd8T7J-wm9S Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´, Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
        else:
            await safe_edit_or_send(callback_query, processed_text, node_id="DDmAXMnH_Dyd8T7J-wm9S", reply_markup=keyboard if keyboard is not None else None)
    # ÐÐ’Ð¢ÐžÐŸÐ•Ð Ð•Ð¥ÐžÐ”: ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ ÑƒÐ·Ð»Ð°
    # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: ÐÐ• Ð´ÐµÐ»Ð°ÐµÐ¼ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ ÐµÑÐ»Ð¸ Ð±Ñ‹Ð»Ð° Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½Ð° ÑƒÑÐ»Ð¾Ð²Ð½Ð°Ñ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ð°
    user_id = callback_query.from_user.id
    has_conditional_keyboard = user_data.get(user_id, {}).get("_has_conditional_keyboard", False)
    if has_conditional_keyboard:
        logging.info("â¸ï¸ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ ÐžÐ¢Ð›ÐžÐ–Ð•Ð: Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½Ð° ÑƒÑÐ»Ð¾Ð²Ð½Ð°Ñ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ð° - Ð¶Ð´Ñ‘Ð¼ Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸")
    elif user_id in user_data and ("waiting_for_input" in user_data[user_id] or "waiting_for_conditional_input" in user_data[user_id]):
        logging.info(f"â¸ï¸ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ ÐžÐ¢Ð›ÐžÐ–Ð•Ð: Ð¾Ð¶Ð¸Ð´Ð°ÐµÐ¼ Ð²Ð²Ð¾Ð´ Ð´Ð»Ñ ÑƒÐ·Ð»Ð° DDmAXMnH_Dyd8T7J-wm9S")
    # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð•: ÐÐ• Ð´ÐµÐ»Ð°ÐµÐ¼ Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ ÐµÑÐ»Ð¸ collectUserInput=true (ÑƒÐ·ÐµÐ» Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´)
    elif user_id in user_data and user_data[user_id].get("collectUserInput_DDmAXMnH_Dyd8T7J-wm9S", True) == True:
        logging.info(f"â„¹ï¸ Ð£Ð·ÐµÐ» DDmAXMnH_Dyd8T7J-wm9S Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´ (collectUserInput=true Ð¸Ð· user_data), Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½")
    else:
        # âš¡ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ðº ÑƒÐ·Ð»Ñƒ 2pmaMDNyVr3oVOHL98LwP
        logging.info(f"âš¡ ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð¾Ñ‚ ÑƒÐ·Ð»Ð° DDmAXMnH_Dyd8T7J-wm9S Ðº ÑƒÐ·Ð»Ñƒ 2pmaMDNyVr3oVOHL98LwP")
        await handle_callback_2pmaMDNyVr3oVOHL98LwP(callback_query)
        logging.info(f"âœ… ÐÐ²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½: DDmAXMnH_Dyd8T7J-wm9S -> 2pmaMDNyVr3oVOHL98LwP")
        return
    
    user_id = callback_query.from_user.id
    
    
    return

@dp.callback_query(lambda c: c.data == "2pmaMDNyVr3oVOHL98LwP" or c.data.startswith("2pmaMDNyVr3oVOHL98LwP_btn_") or c.data == "done_oVOHL98LwP")
async def handle_callback_2pmaMDNyVr3oVOHL98LwP(callback_query: types.CallbackQuery):
    # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· callback_query
    try:
        user_id = callback_query.from_user.id
        callback_data = callback_query.data
        logging.info(f"ðŸ”µ Ð’Ñ‹Ð·Ð²Ð°Ð½ callback handler: handle_callback_2pmaMDNyVr3oVOHL98LwP Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {user_id}")
    except Exception as e:
        logging.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ðº callback_query Ð² handle_callback_2pmaMDNyVr3oVOHL98LwP: {e}")
        return
    
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ„Ð»Ð°Ð³ hideAfterClick Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿Ð¾Ðº
    
    
    # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ñ‚ÑŒ Ð½Ð° callback (Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÑƒ ÐµÑÐ»Ð¸ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½)
    try:
        await callback_query.answer()
    except Exception:
        pass  # Ð˜Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÑƒ ÐµÑÐ»Ð¸ callback ÑƒÐ¶Ðµ Ð±Ñ‹Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½ (Ð¿Ñ€Ð¸ Ð²Ñ‹Ð·Ð¾Ð²Ðµ Ñ‡ÐµÑ€ÐµÐ· Ð°Ð²Ñ‚Ð¾Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´)
    
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    user_name = init_user_variables(user_id, callback_query.from_user)
    
    # Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ñ„Ð»Ð°Ð³ collectUserInput Ð´Ð»Ñ ÑƒÐ·Ð»Ð° 2pmaMDNyVr3oVOHL98LwP
    if user_id not in user_data:
        user_data[user_id] = {}
    user_data[user_id]["collectUserInput_2pmaMDNyVr3oVOHL98LwP"] = False
    logging.info(f"â„¹ï¸ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ„Ð»Ð°Ð³ collectUserInput Ð´Ð»Ñ ÑƒÐ·Ð»Ð° 2pmaMDNyVr3oVOHL98LwP: false")
    
    # ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ ÑƒÐ·ÐµÐ» 2pmaMDNyVr3oVOHL98LwP: 2pmaMDNyVr3oVOHL98LwP
    text = "âš™ï¸ ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð¾Ñ‚Ð°:"
    
    # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ documentUrl Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ document_url_2pmaMDNyVr3oVOHL98LwP
    user_data[user_id]["document_url_2pmaMDNyVr3oVOHL98LwP"] = "â€‹https://img.freepik.com/free-photo/cartoon-style-hugging-day-celebration_23-2151033271.jpg?semt=ais_hybrid&w=740"
    await update_user_data_in_db(user_id, "document_url_2pmaMDNyVr3oVOHL98LwP", "â€‹https://img.freepik.com/free-photo/cartoon-style-hugging-day-celebration_23-2151033271.jpg?semt=ais_hybrid&w=740")
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚
    if user_id not in user_data or "user_name" not in user_data.get(user_id, {}):
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ callback
        user_obj = None
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ message (Ð´Ð»Ñ message handlers)
        if 'message' in locals() and hasattr(locals().get('message'), 'from_user'):
            user_obj = locals().get('message').from_user
        # Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ callback_query (Ð´Ð»Ñ callback handlers)
        elif 'callback_query' in locals() and hasattr(locals().get('callback_query'), 'from_user'):
            user_obj = locals().get('callback_query').from_user

        if user_obj:
            init_user_variables(user_id, user_obj)
    
    # ÐŸÐ¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‚ÐµÐºÑÑ‚
    user_vars = await get_user_from_db(user_id)
    if not user_vars:
        user_vars = user_data.get(user_id, {})
    
    # get_user_from_db Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ user_data
    if not isinstance(user_vars, dict):
        user_vars = user_data.get(user_id, {})
    keyboard = None
    
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ ÑƒÑÐ»Ð¾Ð²Ð½Ð°Ñ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ð° Ð´Ð»Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ
    # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ conditional_keyboard, ÐµÑÐ»Ð¸ Ð¾Ð½Ð° Ð½Ðµ Ð±Ñ‹Ð»Ð° Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð°
    if "conditional_keyboard" not in locals():
        conditional_keyboard = None
    user_id = callback_query.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if "conditional_keyboard" in locals() and conditional_keyboard is not None:
        keyboard = conditional_keyboard
        user_data[user_id]["_has_conditional_keyboard"] = True
        logging.info("âœ… Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÑƒÑÐ»Ð¾Ð²Ð½ÑƒÑŽ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñƒ Ð´Ð»Ñ Ð½Ð°Ð²Ð¸Ð³Ð°Ñ†Ð¸Ð¸")
    else:
        user_data[user_id]["_has_conditional_keyboard"] = False
    
    # ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ (Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¾Ð¹ Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð°)
    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼ÐµÐ´Ð¸Ð° Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ document_url_2pmaMDNyVr3oVOHL98LwP
    attached_media = None
    if user_vars and "document_url_2pmaMDNyVr3oVOHL98LwP" in user_vars:
        media_data = user_vars["document_url_2pmaMDNyVr3oVOHL98LwP"]
        if isinstance(media_data, dict) and "value" in media_data:
            attached_media = media_data["value"]
        elif isinstance(media_data, str):
            attached_media = media_data
    else:
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð¼ÐµÐ´Ð¸Ð° Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
        user_id = callback_query.from_user.id
        user_node_vars = user_data.get(user_id, {})
        if "document_url_2pmaMDNyVr3oVOHL98LwP" in user_node_vars:
            attached_media = user_node_vars["document_url_2pmaMDNyVr3oVOHL98LwP"]
    
    # Ð•ÑÐ»Ð¸ Ð¼ÐµÐ´Ð¸Ð° Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ñ Ð¼ÐµÐ´Ð¸Ð°, Ð¸Ð½Ð°Ñ‡Ðµ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    if attached_media and str(attached_media).strip():
        logging.info(f"ðŸ“Ž ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° document Ð¼ÐµÐ´Ð¸Ð° Ð¸Ð· Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ document_url_2pmaMDNyVr3oVOHL98LwP: {attached_media}")
        try:
            # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð² Ñ‚ÐµÐºÑÑ‚Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¾Ð¹ Ð¼ÐµÐ´Ð¸Ð°
            processed_caption = replace_variables_in_text(text, user_vars)
            await bot.send_document(callback_query.from_user.id, attached_media, caption=processed_caption, reply_markup=keyboard)
        except Exception as e:
            logging.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ document: {e}")
            # Fallback Ð½Ð° Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ
            await safe_edit_or_send(callback_query, text, node_id="2pmaMDNyVr3oVOHL98LwP", reply_markup=keyboard if keyboard is not None else None)
    else:
        # ÐœÐµÐ´Ð¸Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        logging.info(f"ðŸ“ ÐœÐµÐ´Ð¸Ð° document_url_2pmaMDNyVr3oVOHL98LwP Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
        # Ð—Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð² Ñ‚ÐµÐºÑÑ‚Ðµ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¾Ð¹
        processed_text = replace_variables_in_text(text, user_vars)
        if False:
            # Ð£Ð·ÐµÐ» Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´, Ð½Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
            logging.info(f"â„¹ï¸ Ð£Ð·ÐµÐ» 2pmaMDNyVr3oVOHL98LwP Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ Ð²Ð²Ð¾Ð´, Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
        else:
            await safe_edit_or_send(callback_query, processed_text, node_id="2pmaMDNyVr3oVOHL98LwP", reply_markup=keyboard if keyboard is not None else None)
    user_id = callback_query.from_user.id
    
    
    return

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿Ð¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´
# ÐÐ°Ð¹Ð´ÐµÐ½Ð¾ 2 ÐºÐ½Ð¾Ð¿Ð¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´: cmd_language, cmd_notifications

@dp.callback_query(lambda c: c.data == "cmd_language")
async def handle_cmd_language(callback_query: types.CallbackQuery):
    await callback_query.answer()
    logging.info(f"ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ½Ð¾Ð¿ÐºÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹: cmd_language -> /language (Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {callback_query.from_user.id})")
    # Ð¡Ð¸Ð¼ÑƒÐ»Ð¸ÑÑƒÐµÐ¼ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /language
    
    # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ fake message object Ð´Ð»Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹
    from types import SimpleNamespace
    fake_message = SimpleNamespace()
    fake_message.from_user = callback_query.from_user
    fake_message.chat = callback_query.message.chat
    fake_message.date = callback_query.message.date
    fake_message.answer = callback_query.message.answer
    fake_message.edit_text = callback_query.message.edit_text
    
    await callback_query.message.edit_text("ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /language Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð°")
    logging.info(f"ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /language Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð° Ñ‡ÐµÑ€ÐµÐ· callback ÐºÐ½Ð¾Ð¿ÐºÑƒ (Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {callback_query.from_user.id})")

@dp.callback_query(lambda c: c.data == "cmd_notifications")
async def handle_cmd_notifications(callback_query: types.CallbackQuery):
    await callback_query.answer()
    logging.info(f"ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ½Ð¾Ð¿ÐºÐ¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹: cmd_notifications -> /notifications (Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {callback_query.from_user.id})")
    # Ð¡Ð¸Ð¼ÑƒÐ»Ð¸ÑÑƒÐµÐ¼ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /notifications
    
    # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ fake message object Ð´Ð»Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹
    from types import SimpleNamespace
    fake_message = SimpleNamespace()
    fake_message.from_user = callback_query.from_user
    fake_message.chat = callback_query.message.chat
    fake_message.date = callback_query.message.date
    fake_message.answer = callback_query.message.answer
    fake_message.edit_text = callback_query.message.edit_text
    
    await callback_query.message.edit_text("ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /notifications Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð°")
    logging.info(f"ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /notifications Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð° Ñ‡ÐµÑ€ÐµÐ· callback ÐºÐ½Ð¾Ð¿ÐºÑƒ (Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {callback_query.from_user.id})")

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð´Ð»Ñ Ð³Ñ€ÑƒÐ¿Ð¿ Ð±Ð¾Ñ‚Ð°

# Ð£Ð½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ð¹ fallback-Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ Ð²ÑÐµÑ… Ð½ÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ñ… Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
@dp.message(F.text)
async def fallback_text_handler(message: types.Message):
    """
    Fallback Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ Ð²ÑÐµÑ… Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð±ÐµÐ· ÑÐ¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°.
    Ð‘Ð»Ð°Ð³Ð¾Ð´Ð°Ñ€Ñ middleware, ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑƒÐ¶Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾ Ð² Ð‘Ð”.
    Ð­Ñ‚Ð¾Ñ‚ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð»Ð¾Ð³Ð¸Ñ€ÑƒÐµÑ‚ Ñ„Ð°ÐºÑ‚ Ð½ÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.
    """
    logging.info(f"ðŸ’¬ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ Ð½ÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð¾Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ {message.from_user.id}: {message.text}")
    # ÐœÐ¾Ð¶Ð½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)
    # await message.answer("Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ñ Ð½Ðµ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÑŽ ÑÑ‚Ñƒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ /start Ð´Ð»Ñ Ð½Ð°Ñ‡Ð°Ð»Ð°.")


# Ð£Ð½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ Ð½ÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ñ… Ñ„Ð¾Ñ‚Ð¾
@dp.message(F.photo)
async def handle_unhandled_photo(message: types.Message):
    """
    ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ð¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½Ðµ Ð±Ñ‹Ð»Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ñ‹ Ð´Ñ€ÑƒÐ³Ð¸Ð¼Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°Ð¼Ð¸.
    Ð‘Ð»Ð°Ð³Ð¾Ð´Ð°Ñ€Ñ middleware, Ñ„Ð¾Ñ‚Ð¾ ÑƒÐ¶Ðµ Ð±ÑƒÐ´ÐµÑ‚ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾ Ð² Ð‘Ð”.
    """
    logging.info(f"ðŸ“¸ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ Ñ„Ð¾Ñ‚Ð¾ Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.from_user.id}")
    # Middleware Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ Ñ„Ð¾Ñ‚Ð¾



# Ð—Ð°Ð¿ÑƒÑÐº Ð±Ð¾Ñ‚Ð°
async def main():
    global db_pool
    
    # ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº ÑÐ¸Ð³Ð½Ð°Ð»Ð¾Ð² Ð´Ð»Ñ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ
    def signal_handler(signum, frame):
        print(f"ðŸ›‘ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ ÑÐ¸Ð³Ð½Ð°Ð» {signum}, Ð½Ð°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ...")
        raise KeyboardInterrupt()
    
    # Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ ÑÐ¸Ð³Ð½Ð°Ð»Ð¾Ð²
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
        await init_database()
        await set_bot_commands()
        
        # Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ middleware Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
        dp.message.middleware(message_logging_middleware)
        
        print("ðŸ¤– Ð‘Ð¾Ñ‚ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Ð¸ Ð³Ð¾Ñ‚Ð¾Ð² Ðº Ñ€Ð°Ð±Ð¾Ñ‚Ðµ!")
        await dp.start_polling(bot)
    except KeyboardInterrupt:
        print("ðŸ›‘ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ ÑÐ¸Ð³Ð½Ð°Ð» Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸, Ð·Ð°Ð²ÐµÑ€ÑˆÐ°ÐµÐ¼ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ...")
    except SystemExit:
        print("ðŸ›‘ Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð½Ð¾Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ, Ð·Ð°Ð²ÐµÑ€ÑˆÐ°ÐµÐ¼ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ...")
    except Exception as e:
        logging.error(f"ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {e}")
    finally:
        # ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾ Ð·Ð°ÐºÑ€Ñ‹Ð²Ð°ÐµÐ¼ Ð²ÑÐµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ
        if db_pool:
            await db_pool.close()
            print("ðŸ”Œ Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¾")
        
        # Ð—Ð°ÐºÑ€Ñ‹Ð²Ð°ÐµÐ¼ ÑÐµÑÑÐ¸ÑŽ Ð±Ð¾Ñ‚Ð°
        await bot.session.close()
        print("ðŸ”Œ Ð¡ÐµÑÑÐ¸Ñ Ð±Ð¾Ñ‚Ð° Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°")
        print("âœ… Ð‘Ð¾Ñ‚ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ")

        return
    
if __name__ == "__main__":
    asyncio.run(main())
