{"code":"\"\"\"\nТест индивидуальной навигации кнопок - Telegram Bot\nСгенерировано с помощью TelegramBot Builder\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nfrom aiogram import Bot, Dispatcher, types, F\nfrom aiogram.filters import CommandStart, Command\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, BotCommand, ReplyKeyboardRemove, URLInputFile, FSInputFile\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\nfrom aiogram.enums import ParseMode\nimport asyncpg\nfrom datetime import datetime\nimport json\n\n# Токен вашего бота (получите у @BotFather)\nBOT_TOKEN = \"YOUR_BOT_TOKEN_HERE\"\n\n# Настройка логирования\nlogging.basicConfig(level=logging.INFO)\n\n# Создание бота и диспетчера\nbot = Bot(token=BOT_TOKEN)\ndp = Dispatcher()\n\n# Список администраторов (добавьте свой Telegram ID)\nADMIN_IDS = [123456789]  # Замените на реальные ID администраторов\n\n# Настройки базы данных\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql://user:password@localhost:5432/bot_db\")\n\n# Пул соединений с базой данных\ndb_pool = None\n\n# Хранилище пользователей (резервное для случаев без БД)\nuser_data = {}\n\n\n# Функции для работы с базой данных\nasync def init_database():\n    \"\"\"Инициализация подключения к базе данных и создание таблиц\"\"\"\n    global db_pool\n    try:\n        db_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)\n        # Создаем таблицу пользователей если её нет\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS bot_users (\n                    user_id BIGINT PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    registered_at TIMESTAMP DEFAULT NOW(),\n                    last_interaction TIMESTAMP DEFAULT NOW(),\n                    interaction_count INTEGER DEFAULT 0,\n                    user_data JSONB DEFAULT '{}',\n                    is_active BOOLEAN DEFAULT TRUE\n                );\n            \"\"\")\n        logging.info(\"✅ База данных инициализирована\")\n    except Exception as e:\n        logging.warning(f\"⚠️ Не удалось подключиться к БД: {e}. Используем локальное хранилище.\")\n        db_pool = None\n\nasync def save_user_to_db(user_id: int, username: str = None, first_name: str = None, last_name: str = None):\n    \"\"\"Сохраняет пользователя в базу данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id, username, first_name, last_name)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (user_id) DO UPDATE SET\n                    username = EXCLUDED.username,\n                    first_name = EXCLUDED.first_name,\n                    last_name = EXCLUDED.last_name,\n                    last_interaction = NOW(),\n                    interaction_count = bot_users.interaction_count + 1\n            \"\"\", user_id, username, first_name, last_name)\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка сохранения пользователя в БД: {e}\")\n        return False\n\nasync def get_user_from_db(user_id: int):\n    \"\"\"Получает данные пользователя из базы данных\"\"\"\n    if not db_pool:\n        return None\n    try:\n        async with db_pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM bot_users WHERE user_id = $1\", user_id)\n            if row:\n                return dict(row)\n        return None\n    except Exception as e:\n        logging.error(f\"Ошибка получения пользователя из БД: {e}\")\n        return None\n\nasync def update_user_data_in_db(user_id: int, data_key: str, data_value):\n    \"\"\"Обновляет пользовательские данные в базе данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                UPDATE bot_users \n                SET user_data = user_data || $2::jsonb,\n                    last_interaction = NOW()\n                WHERE user_id = $1\n            \"\"\", user_id, json.dumps({data_key: data_value}))\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка обновления данных пользователя: {e}\")\n        return False\n\n\n# Утилитарные функции\nasync def is_admin(user_id: int) -> bool:\n    return user_id in ADMIN_IDS\n\nasync def is_private_chat(message: types.Message) -> bool:\n    return message.chat.type == \"private\"\n\nasync def check_auth(user_id: int) -> bool:\n    # Проверяем наличие пользователя в БД или локальном хранилище\n    if db_pool:\n        user = await get_user_from_db(user_id)\n        return user is not None\n    return user_id in user_data\n\ndef is_local_file(url: str) -> bool:\n    \"\"\"Проверяет, является ли URL локальным загруженным файлом\"\"\"\n    return url.startswith(\"/uploads/\") or url.startswith(\"uploads/\")\n\ndef get_local_file_path(url: str) -> str:\n    \"\"\"Получает локальный путь к файлу из URL\"\"\"\n    if url.startswith(\"/\"):\n        return url[1:]  # Убираем ведущий слеш\n    return url\n\ndef extract_coordinates_from_yandex(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Яндекс.Карт\"\"\"\n    import re\n    # Ищем координаты в формате ll=longitude,latitude\n    match = re.search(r\"ll=([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Ищем координаты в формате /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_google(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Google Maps\"\"\"\n    import re\n    # Ищем координаты в формате @latitude,longitude\n    match = re.search(r\"@([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    # Ищем координаты в формате /latitude,longitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_2gis(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки 2ГИС\"\"\"\n    import re\n    # Ищем координаты в различных форматах 2ГИС\n    # Формат: center/longitude,latitude\n    match = re.search(r\"center/([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Формат: /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef generate_map_urls(latitude: float, longitude: float, title: str = \"\") -> dict:\n    \"\"\"Генерирует ссылки на различные картографические сервисы\"\"\"\n    import urllib.parse\n    \n    encoded_title = urllib.parse.quote(title) if title else \"\"\n    \n    return {\n        \"yandex\": f\"https://yandex.ru/maps/?ll={longitude},{latitude}&z=15&l=map&pt={longitude},{latitude}\",\n        \"google\": f\"https://maps.google.com/?q={latitude},{longitude}\",\n        \"2gis\": f\"https://2gis.ru/geo/{longitude},{latitude}\",\n        \"openstreetmap\": f\"https://www.openstreetmap.org/?mlat={latitude}&mlon={longitude}&zoom=15\"\n    }\n\n\n@dp.message(CommandStart())\nasync def start_handler(message: types.Message):\n\n    # Регистрируем пользователя в системе\n    user_id = message.from_user.id\n    username = message.from_user.username\n    first_name = message.from_user.first_name\n    last_name = message.from_user.last_name\n    \n    # Сохраняем пользователя в базу данных\n    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)\n    \n    # Резервное сохранение в локальное хранилище\n    if not saved_to_db:\n        user_data[user_id] = {\n            \"username\": username,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"registered_at\": message.date\n        }\n        logging.info(f\"Пользователь {user_id} сохранен в локальное хранилище\")\n    else:\n        logging.info(f\"Пользователь {user_id} сохранен в базу данных\")\n\n    text = f\"Добро пожаловать! Выберите тип действия:\"\n    \n    # Создаем inline клавиатуру с кнопками\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"Начать опрос\", callback_data=\"survey-1\"))\n    keyboard = builder.as_markup()\n    # Отправляем сообщение с прикрепленными inline кнопками\n    await message.answer(text, reply_markup=keyboard)\n\n@dp.message(Command(\"music\"))\nasync def music_handler(message: types.Message):\n    logging.info(f\"Команда /music вызвана пользователем {message.from_user.id}\")\n    # Сохраняем пользователя и статистику использования команд\n    user_id = message.from_user.id\n    username = message.from_user.username\n    first_name = message.from_user.first_name\n    last_name = message.from_user.last_name\n    \n    # Сохраняем пользователя в базу данных\n    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)\n    \n    # Обновляем статистику команд в БД\n    if saved_to_db:\n        await update_user_data_in_db(user_id, \"command_music\", datetime.now().isoformat())\n    \n    # Резервное сохранение в локальное хранилище\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    if \"commands_used\" not in user_data[user_id]:\n        user_data[user_id][\"commands_used\"] = {}\n    user_data[user_id][\"commands_used\"][\"/music\"] = user_data[user_id][\"commands_used\"].get(\"/music\", 0) + 1\n\n    text = f\"🎵 Музыка - язык души! Какой жанр предпочитаете?\"\n    \n    # Создаем inline клавиатуру с кнопками\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"🎸 Рок\", callback_data=\"start-1\"))\n    builder.add(InlineKeyboardButton(text=\"🎤 Поп\", callback_data=\"start-1\"))\n    keyboard = builder.as_markup()\n    # Отправляем сообщение с прикрепленными inline кнопками\n    await message.answer(text, reply_markup=keyboard)\n\n# Обработчики inline кнопок\n\n@dp.callback_query(lambda c: c.data == \"survey-1\")\nasync def handle_callback_survey_1(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Удаляем старое сообщение\n    await callback_query.message.delete()\n    \n    text = f\"Что вас интересует?\"\n    \n    # Создаем кнопки для выбора ответа\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"📱 Технологии\", callback_data=\"response_survey-1_0\"))\n    builder.add(InlineKeyboardButton(text=\"🎵 Музыка\", callback_data=\"response_survey-1_1\"))\n    builder.add(InlineKeyboardButton(text=\"🌐 Сайт\", callback_data=\"response_survey-1_2\"))\n    builder.add(InlineKeyboardButton(text=\"🔄 Главное меню\", callback_data=\"response_survey-1_3\"))\n    keyboard = builder.as_markup()\n    await bot.send_message(callback_query.from_user.id, text, reply_markup=keyboard)\n    \n    # Инициализируем пользовательские данные если их нет\n    if callback_query.from_user.id not in user_data:\n        user_data[callback_query.from_user.id] = {}\n    \n    # Сохраняем настройки для обработки ответа\n    user_data[callback_query.from_user.id][\"button_response_config\"] = {\n        \"node_id\": \"survey-1\",\n        \"variable\": \"user_interest\",\n        \"save_to_database\": True,\n        \"success_message\": \"Спасибо за ваш ответ!\",\n        \"allow_multiple\": False,\n        \"next_node_id\": \"tech-info\",\n        \"options\": [\n            {\"index\": 0, \"text\": \"📱 Технологии\", \"value\": \"tech\", \"action\": \"goto\", \"target\": \"tech-info\", \"url\": \"\"},\n            {\"index\": 1, \"text\": \"🎵 Музыка\", \"value\": \"music\", \"action\": \"command\", \"target\": \"/music\", \"url\": \"\"},\n            {\"index\": 2, \"text\": \"🌐 Сайт\", \"value\": \"website\", \"action\": \"url\", \"target\": \"\", \"url\": \"https://example.com\"},\n            {\"index\": 3, \"text\": \"🔄 Главное меню\", \"value\": \"menu\", \"action\": \"goto\", \"target\": \"start-1\", \"url\": \"\"},\n        ],\n        \"selected\": []\n    }\n\n@dp.callback_query(lambda c: c.data == \"start-1\")\nasync def handle_callback_start_1(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    text = \"Добро пожаловать! Выберите тип действия:\"\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"Начать опрос\", callback_data=\"survey-1\"))\n    keyboard = builder.as_markup()\n    await callback_query.message.edit_text(text, reply_markup=keyboard)\n\n# Обработчики кнопочных ответов для сбора пользовательского ввода\n\n@dp.callback_query(F.data == \"response_survey-1_0\")\nasync def handle_response_survey_1_0(callback_query: types.CallbackQuery):\n    user_id = callback_query.from_user.id\n    \n    # Проверяем настройки кнопочного ответа\n    if user_id not in user_data or \"button_response_config\" not in user_data[user_id]:\n        await callback_query.answer(\"⚠️ Сессия истекла, попробуйте снова\", show_alert=True)\n        return\n    \n    config = user_data[user_id][\"button_response_config\"]\n    selected_value = \"tech\"\n    selected_text = \"📱 Технологии\"\n    \n    # Обработка множественного выбора\n    if config.get(\"allow_multiple\"):\n        # Проверяем, является ли это кнопкой \"Готово\" для завершения выбора\n        if selected_value == \"done\":\n            # Завершаем множественный выбор\n            if len(config[\"selected\"]) > 0:\n                # Сохраняем все выбранные элементы\n                variable_name = config.get(\"variable\", \"user_response\")\n                import datetime\n                timestamp = datetime.datetime.now().isoformat()\n                node_id = config.get(\"node_id\", \"unknown\")\n                \n                # Создаем структурированный ответ для множественного выбора\n                response_data = {\n                    \"value\": [item[\"value\"] for item in config[\"selected\"]],\n                    \"text\": [item[\"text\"] for item in config[\"selected\"]],\n                    \"type\": \"multiple_choice\",\n                    \"timestamp\": timestamp,\n                    \"nodeId\": node_id,\n                    \"variable\": variable_name\n                }\n                \n                # Сохраняем в пользовательские данные\n                user_data[user_id][variable_name] = response_data\n                \n                # Сохраняем в базу данных если включено\n                if config.get(\"save_to_database\"):\n                    saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                    if saved_to_db:\n                        logging.info(f\"✅ Множественный выбор сохранен в БД: {variable_name} = {response_data['text']} (пользователь {user_id})\")\n                    else:\n                        logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n                \n                # Отправляем сообщение об успехе\n                success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n                selected_items = \", \".join([item[\"text\"] for item in config[\"selected\"]])\n                await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_items}\")\n                \n                logging.info(f\"Получен множественный выбор: {variable_name} = {[item['text'] for item in config['selected']]}\")\n                \n                # Очищаем состояние\n                del user_data[user_id][\"button_response_config\"]\n                \n                # Автоматическая навигация к следующему узлу\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start-1\":\n                            await handle_callback_start_1(callback_query)\n                        elif next_node_id == \"survey-1\":\n                            await handle_callback_survey_1(callback_query)\n                        elif next_node_id == \"tech-info\":\n                            await handle_callback_tech_info(callback_query)\n                        elif next_node_id == \"music-cmd\":\n                            await handle_callback_music_cmd(callback_query)\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n                return\n            else:\n                # Если ничего не выбрано, показываем предупреждение\n                await callback_query.answer(\"⚠️ Выберите хотя бы один вариант перед завершением\", show_alert=True)\n                return\n        else:\n            # Обычная логика множественного выбора\n            if selected_value not in config[\"selected\"]:\n                config[\"selected\"].append({\"text\": selected_text, \"value\": selected_value})\n                await callback_query.answer(f\"✅ Выбрано: {selected_text}\")\n            else:\n                config[\"selected\"] = [item for item in config[\"selected\"] if item[\"value\"] != selected_value]\n                await callback_query.answer(f\"❌ Убрано: {selected_text}\")\n            return  # Не завершаем сбор, позволяем выбрать еще\n    \n    # Сохраняем одиночный выбор\n    variable_name = config.get(\"variable\", \"user_response\")\n    import datetime\n    timestamp = datetime.datetime.now().isoformat()\n    node_id = config.get(\"node_id\", \"unknown\")\n    \n    # Создаем структурированный ответ\n    response_data = {\n        \"value\": selected_value,\n        \"text\": selected_text,\n        \"type\": \"button_choice\",\n        \"timestamp\": timestamp,\n        \"nodeId\": node_id,\n        \"variable\": variable_name\n    }\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n    await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\")\n    \n    # Очищаем состояние\n    del user_data[user_id][\"button_response_config\"]\n    \n    logging.info(f\"Получен кнопочный ответ: {variable_name} = {selected_text}\")\n    \n    # Навигация на основе индивидуальных настроек кнопки\n    # Находим настройки для этого конкретного варианта ответа\n    options = config.get(\"options\", [])\n    current_option = None\n    for option in options:\n        if option.get(\"callback_data\") == \"response_survey-1_0\":\n            current_option = option\n            break\n    \n    if current_option:\n        option_action = current_option.get(\"action\", \"goto\")\n        option_target = current_option.get(\"target\", \"\")\n        option_url = current_option.get(\"url\", \"\")\n        \n        if option_action == \"url\" and option_url:\n            # Открываем ссылку\n            from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup\n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=option_url)]\n            ])\n            await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=keyboard)\n        elif option_action == \"command\" and option_target:\n            # Выполняем команду\n            command = option_target\n            if not command.startswith(\"/\"):\n                command = \"/\" + command\n            \n            # Создаем фиктивное сообщение для выполнения команды\n            import aiogram.types as aiogram_types\n            fake_message = aiogram_types.SimpleNamespace(\n                from_user=callback_query.from_user,\n                chat=callback_query.message.chat,\n                text=command,\n                message_id=callback_query.message.message_id\n            )\n            \n            if command == \"/start\":\n                try:\n                    await start_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /start: {e}\")\n            elif command == \"/music\":\n                try:\n                    await _music_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /music: {e}\")\n            else:\n                logging.warning(f\"Неизвестная команда: {command}\")\n        elif option_action == \"goto\" and option_target:\n            # Переход к узлу\n            target_node_id = option_target\n            try:\n                # Вызываем обработчик для целевого узла\n                if target_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif target_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif target_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif target_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n    else:\n        # Fallback к старой системе next_node_id если нет настроек кнопки\n        next_node_id = config.get(\"next_node_id\")\n        if next_node_id:\n            try:\n                # Вызываем обработчик для следующего узла\n                if next_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif next_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif next_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif next_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n@dp.callback_query(F.data == \"response_survey-1_1\")\nasync def handle_response_survey_1_1(callback_query: types.CallbackQuery):\n    user_id = callback_query.from_user.id\n    \n    # Проверяем настройки кнопочного ответа\n    if user_id not in user_data or \"button_response_config\" not in user_data[user_id]:\n        await callback_query.answer(\"⚠️ Сессия истекла, попробуйте снова\", show_alert=True)\n        return\n    \n    config = user_data[user_id][\"button_response_config\"]\n    selected_value = \"music\"\n    selected_text = \"🎵 Музыка\"\n    \n    # Обработка множественного выбора\n    if config.get(\"allow_multiple\"):\n        # Проверяем, является ли это кнопкой \"Готово\" для завершения выбора\n        if selected_value == \"done\":\n            # Завершаем множественный выбор\n            if len(config[\"selected\"]) > 0:\n                # Сохраняем все выбранные элементы\n                variable_name = config.get(\"variable\", \"user_response\")\n                import datetime\n                timestamp = datetime.datetime.now().isoformat()\n                node_id = config.get(\"node_id\", \"unknown\")\n                \n                # Создаем структурированный ответ для множественного выбора\n                response_data = {\n                    \"value\": [item[\"value\"] for item in config[\"selected\"]],\n                    \"text\": [item[\"text\"] for item in config[\"selected\"]],\n                    \"type\": \"multiple_choice\",\n                    \"timestamp\": timestamp,\n                    \"nodeId\": node_id,\n                    \"variable\": variable_name\n                }\n                \n                # Сохраняем в пользовательские данные\n                user_data[user_id][variable_name] = response_data\n                \n                # Сохраняем в базу данных если включено\n                if config.get(\"save_to_database\"):\n                    saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                    if saved_to_db:\n                        logging.info(f\"✅ Множественный выбор сохранен в БД: {variable_name} = {response_data['text']} (пользователь {user_id})\")\n                    else:\n                        logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n                \n                # Отправляем сообщение об успехе\n                success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n                selected_items = \", \".join([item[\"text\"] for item in config[\"selected\"]])\n                await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_items}\")\n                \n                logging.info(f\"Получен множественный выбор: {variable_name} = {[item['text'] for item in config['selected']]}\")\n                \n                # Очищаем состояние\n                del user_data[user_id][\"button_response_config\"]\n                \n                # Автоматическая навигация к следующему узлу\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start-1\":\n                            await handle_callback_start_1(callback_query)\n                        elif next_node_id == \"survey-1\":\n                            await handle_callback_survey_1(callback_query)\n                        elif next_node_id == \"tech-info\":\n                            await handle_callback_tech_info(callback_query)\n                        elif next_node_id == \"music-cmd\":\n                            await handle_callback_music_cmd(callback_query)\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n                return\n            else:\n                # Если ничего не выбрано, показываем предупреждение\n                await callback_query.answer(\"⚠️ Выберите хотя бы один вариант перед завершением\", show_alert=True)\n                return\n        else:\n            # Обычная логика множественного выбора\n            if selected_value not in config[\"selected\"]:\n                config[\"selected\"].append({\"text\": selected_text, \"value\": selected_value})\n                await callback_query.answer(f\"✅ Выбрано: {selected_text}\")\n            else:\n                config[\"selected\"] = [item for item in config[\"selected\"] if item[\"value\"] != selected_value]\n                await callback_query.answer(f\"❌ Убрано: {selected_text}\")\n            return  # Не завершаем сбор, позволяем выбрать еще\n    \n    # Сохраняем одиночный выбор\n    variable_name = config.get(\"variable\", \"user_response\")\n    import datetime\n    timestamp = datetime.datetime.now().isoformat()\n    node_id = config.get(\"node_id\", \"unknown\")\n    \n    # Создаем структурированный ответ\n    response_data = {\n        \"value\": selected_value,\n        \"text\": selected_text,\n        \"type\": \"button_choice\",\n        \"timestamp\": timestamp,\n        \"nodeId\": node_id,\n        \"variable\": variable_name\n    }\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n    await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\")\n    \n    # Очищаем состояние\n    del user_data[user_id][\"button_response_config\"]\n    \n    logging.info(f\"Получен кнопочный ответ: {variable_name} = {selected_text}\")\n    \n    # Навигация на основе индивидуальных настроек кнопки\n    # Находим настройки для этого конкретного варианта ответа\n    options = config.get(\"options\", [])\n    current_option = None\n    for option in options:\n        if option.get(\"callback_data\") == \"response_survey-1_1\":\n            current_option = option\n            break\n    \n    if current_option:\n        option_action = current_option.get(\"action\", \"goto\")\n        option_target = current_option.get(\"target\", \"\")\n        option_url = current_option.get(\"url\", \"\")\n        \n        if option_action == \"url\" and option_url:\n            # Открываем ссылку\n            from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup\n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=option_url)]\n            ])\n            await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=keyboard)\n        elif option_action == \"command\" and option_target:\n            # Выполняем команду\n            command = option_target\n            if not command.startswith(\"/\"):\n                command = \"/\" + command\n            \n            # Создаем фиктивное сообщение для выполнения команды\n            import aiogram.types as aiogram_types\n            fake_message = aiogram_types.SimpleNamespace(\n                from_user=callback_query.from_user,\n                chat=callback_query.message.chat,\n                text=command,\n                message_id=callback_query.message.message_id\n            )\n            \n            if command == \"/start\":\n                try:\n                    await start_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /start: {e}\")\n            elif command == \"/music\":\n                try:\n                    await _music_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /music: {e}\")\n            else:\n                logging.warning(f\"Неизвестная команда: {command}\")\n        elif option_action == \"goto\" and option_target:\n            # Переход к узлу\n            target_node_id = option_target\n            try:\n                # Вызываем обработчик для целевого узла\n                if target_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif target_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif target_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif target_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n    else:\n        # Fallback к старой системе next_node_id если нет настроек кнопки\n        next_node_id = config.get(\"next_node_id\")\n        if next_node_id:\n            try:\n                # Вызываем обработчик для следующего узла\n                if next_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif next_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif next_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif next_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n@dp.callback_query(F.data == \"response_survey-1_2\")\nasync def handle_response_survey_1_2(callback_query: types.CallbackQuery):\n    user_id = callback_query.from_user.id\n    \n    # Проверяем настройки кнопочного ответа\n    if user_id not in user_data or \"button_response_config\" not in user_data[user_id]:\n        await callback_query.answer(\"⚠️ Сессия истекла, попробуйте снова\", show_alert=True)\n        return\n    \n    config = user_data[user_id][\"button_response_config\"]\n    selected_value = \"website\"\n    selected_text = \"🌐 Сайт\"\n    \n    # Обработка множественного выбора\n    if config.get(\"allow_multiple\"):\n        # Проверяем, является ли это кнопкой \"Готово\" для завершения выбора\n        if selected_value == \"done\":\n            # Завершаем множественный выбор\n            if len(config[\"selected\"]) > 0:\n                # Сохраняем все выбранные элементы\n                variable_name = config.get(\"variable\", \"user_response\")\n                import datetime\n                timestamp = datetime.datetime.now().isoformat()\n                node_id = config.get(\"node_id\", \"unknown\")\n                \n                # Создаем структурированный ответ для множественного выбора\n                response_data = {\n                    \"value\": [item[\"value\"] for item in config[\"selected\"]],\n                    \"text\": [item[\"text\"] for item in config[\"selected\"]],\n                    \"type\": \"multiple_choice\",\n                    \"timestamp\": timestamp,\n                    \"nodeId\": node_id,\n                    \"variable\": variable_name\n                }\n                \n                # Сохраняем в пользовательские данные\n                user_data[user_id][variable_name] = response_data\n                \n                # Сохраняем в базу данных если включено\n                if config.get(\"save_to_database\"):\n                    saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                    if saved_to_db:\n                        logging.info(f\"✅ Множественный выбор сохранен в БД: {variable_name} = {response_data['text']} (пользователь {user_id})\")\n                    else:\n                        logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n                \n                # Отправляем сообщение об успехе\n                success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n                selected_items = \", \".join([item[\"text\"] for item in config[\"selected\"]])\n                await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_items}\")\n                \n                logging.info(f\"Получен множественный выбор: {variable_name} = {[item['text'] for item in config['selected']]}\")\n                \n                # Очищаем состояние\n                del user_data[user_id][\"button_response_config\"]\n                \n                # Автоматическая навигация к следующему узлу\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start-1\":\n                            await handle_callback_start_1(callback_query)\n                        elif next_node_id == \"survey-1\":\n                            await handle_callback_survey_1(callback_query)\n                        elif next_node_id == \"tech-info\":\n                            await handle_callback_tech_info(callback_query)\n                        elif next_node_id == \"music-cmd\":\n                            await handle_callback_music_cmd(callback_query)\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n                return\n            else:\n                # Если ничего не выбрано, показываем предупреждение\n                await callback_query.answer(\"⚠️ Выберите хотя бы один вариант перед завершением\", show_alert=True)\n                return\n        else:\n            # Обычная логика множественного выбора\n            if selected_value not in config[\"selected\"]:\n                config[\"selected\"].append({\"text\": selected_text, \"value\": selected_value})\n                await callback_query.answer(f\"✅ Выбрано: {selected_text}\")\n            else:\n                config[\"selected\"] = [item for item in config[\"selected\"] if item[\"value\"] != selected_value]\n                await callback_query.answer(f\"❌ Убрано: {selected_text}\")\n            return  # Не завершаем сбор, позволяем выбрать еще\n    \n    # Сохраняем одиночный выбор\n    variable_name = config.get(\"variable\", \"user_response\")\n    import datetime\n    timestamp = datetime.datetime.now().isoformat()\n    node_id = config.get(\"node_id\", \"unknown\")\n    \n    # Создаем структурированный ответ\n    response_data = {\n        \"value\": selected_value,\n        \"text\": selected_text,\n        \"type\": \"button_choice\",\n        \"timestamp\": timestamp,\n        \"nodeId\": node_id,\n        \"variable\": variable_name\n    }\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n    await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\")\n    \n    # Очищаем состояние\n    del user_data[user_id][\"button_response_config\"]\n    \n    logging.info(f\"Получен кнопочный ответ: {variable_name} = {selected_text}\")\n    \n    # Навигация на основе индивидуальных настроек кнопки\n    # Находим настройки для этого конкретного варианта ответа\n    options = config.get(\"options\", [])\n    current_option = None\n    for option in options:\n        if option.get(\"callback_data\") == \"response_survey-1_2\":\n            current_option = option\n            break\n    \n    if current_option:\n        option_action = current_option.get(\"action\", \"goto\")\n        option_target = current_option.get(\"target\", \"\")\n        option_url = current_option.get(\"url\", \"\")\n        \n        if option_action == \"url\" and option_url:\n            # Открываем ссылку\n            from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup\n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=option_url)]\n            ])\n            await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=keyboard)\n        elif option_action == \"command\" and option_target:\n            # Выполняем команду\n            command = option_target\n            if not command.startswith(\"/\"):\n                command = \"/\" + command\n            \n            # Создаем фиктивное сообщение для выполнения команды\n            import aiogram.types as aiogram_types\n            fake_message = aiogram_types.SimpleNamespace(\n                from_user=callback_query.from_user,\n                chat=callback_query.message.chat,\n                text=command,\n                message_id=callback_query.message.message_id\n            )\n            \n            if command == \"/start\":\n                try:\n                    await start_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /start: {e}\")\n            elif command == \"/music\":\n                try:\n                    await _music_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /music: {e}\")\n            else:\n                logging.warning(f\"Неизвестная команда: {command}\")\n        elif option_action == \"goto\" and option_target:\n            # Переход к узлу\n            target_node_id = option_target\n            try:\n                # Вызываем обработчик для целевого узла\n                if target_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif target_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif target_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif target_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n    else:\n        # Fallback к старой системе next_node_id если нет настроек кнопки\n        next_node_id = config.get(\"next_node_id\")\n        if next_node_id:\n            try:\n                # Вызываем обработчик для следующего узла\n                if next_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif next_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif next_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif next_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n@dp.callback_query(F.data == \"response_survey-1_3\")\nasync def handle_response_survey_1_3(callback_query: types.CallbackQuery):\n    user_id = callback_query.from_user.id\n    \n    # Проверяем настройки кнопочного ответа\n    if user_id not in user_data or \"button_response_config\" not in user_data[user_id]:\n        await callback_query.answer(\"⚠️ Сессия истекла, попробуйте снова\", show_alert=True)\n        return\n    \n    config = user_data[user_id][\"button_response_config\"]\n    selected_value = \"menu\"\n    selected_text = \"🔄 Главное меню\"\n    \n    # Обработка множественного выбора\n    if config.get(\"allow_multiple\"):\n        # Проверяем, является ли это кнопкой \"Готово\" для завершения выбора\n        if selected_value == \"done\":\n            # Завершаем множественный выбор\n            if len(config[\"selected\"]) > 0:\n                # Сохраняем все выбранные элементы\n                variable_name = config.get(\"variable\", \"user_response\")\n                import datetime\n                timestamp = datetime.datetime.now().isoformat()\n                node_id = config.get(\"node_id\", \"unknown\")\n                \n                # Создаем структурированный ответ для множественного выбора\n                response_data = {\n                    \"value\": [item[\"value\"] for item in config[\"selected\"]],\n                    \"text\": [item[\"text\"] for item in config[\"selected\"]],\n                    \"type\": \"multiple_choice\",\n                    \"timestamp\": timestamp,\n                    \"nodeId\": node_id,\n                    \"variable\": variable_name\n                }\n                \n                # Сохраняем в пользовательские данные\n                user_data[user_id][variable_name] = response_data\n                \n                # Сохраняем в базу данных если включено\n                if config.get(\"save_to_database\"):\n                    saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                    if saved_to_db:\n                        logging.info(f\"✅ Множественный выбор сохранен в БД: {variable_name} = {response_data['text']} (пользователь {user_id})\")\n                    else:\n                        logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n                \n                # Отправляем сообщение об успехе\n                success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n                selected_items = \", \".join([item[\"text\"] for item in config[\"selected\"]])\n                await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_items}\")\n                \n                logging.info(f\"Получен множественный выбор: {variable_name} = {[item['text'] for item in config['selected']]}\")\n                \n                # Очищаем состояние\n                del user_data[user_id][\"button_response_config\"]\n                \n                # Автоматическая навигация к следующему узлу\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start-1\":\n                            await handle_callback_start_1(callback_query)\n                        elif next_node_id == \"survey-1\":\n                            await handle_callback_survey_1(callback_query)\n                        elif next_node_id == \"tech-info\":\n                            await handle_callback_tech_info(callback_query)\n                        elif next_node_id == \"music-cmd\":\n                            await handle_callback_music_cmd(callback_query)\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n                return\n            else:\n                # Если ничего не выбрано, показываем предупреждение\n                await callback_query.answer(\"⚠️ Выберите хотя бы один вариант перед завершением\", show_alert=True)\n                return\n        else:\n            # Обычная логика множественного выбора\n            if selected_value not in config[\"selected\"]:\n                config[\"selected\"].append({\"text\": selected_text, \"value\": selected_value})\n                await callback_query.answer(f\"✅ Выбрано: {selected_text}\")\n            else:\n                config[\"selected\"] = [item for item in config[\"selected\"] if item[\"value\"] != selected_value]\n                await callback_query.answer(f\"❌ Убрано: {selected_text}\")\n            return  # Не завершаем сбор, позволяем выбрать еще\n    \n    # Сохраняем одиночный выбор\n    variable_name = config.get(\"variable\", \"user_response\")\n    import datetime\n    timestamp = datetime.datetime.now().isoformat()\n    node_id = config.get(\"node_id\", \"unknown\")\n    \n    # Создаем структурированный ответ\n    response_data = {\n        \"value\": selected_value,\n        \"text\": selected_text,\n        \"type\": \"button_choice\",\n        \"timestamp\": timestamp,\n        \"nodeId\": node_id,\n        \"variable\": variable_name\n    }\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n    await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\")\n    \n    # Очищаем состояние\n    del user_data[user_id][\"button_response_config\"]\n    \n    logging.info(f\"Получен кнопочный ответ: {variable_name} = {selected_text}\")\n    \n    # Навигация на основе индивидуальных настроек кнопки\n    # Находим настройки для этого конкретного варианта ответа\n    options = config.get(\"options\", [])\n    current_option = None\n    for option in options:\n        if option.get(\"callback_data\") == \"response_survey-1_3\":\n            current_option = option\n            break\n    \n    if current_option:\n        option_action = current_option.get(\"action\", \"goto\")\n        option_target = current_option.get(\"target\", \"\")\n        option_url = current_option.get(\"url\", \"\")\n        \n        if option_action == \"url\" and option_url:\n            # Открываем ссылку\n            from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup\n            keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=option_url)]\n            ])\n            await callback_query.message.edit_text(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=keyboard)\n        elif option_action == \"command\" and option_target:\n            # Выполняем команду\n            command = option_target\n            if not command.startswith(\"/\"):\n                command = \"/\" + command\n            \n            # Создаем фиктивное сообщение для выполнения команды\n            import aiogram.types as aiogram_types\n            fake_message = aiogram_types.SimpleNamespace(\n                from_user=callback_query.from_user,\n                chat=callback_query.message.chat,\n                text=command,\n                message_id=callback_query.message.message_id\n            )\n            \n            if command == \"/start\":\n                try:\n                    await start_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /start: {e}\")\n            elif command == \"/music\":\n                try:\n                    await _music_handler(fake_message)\n                except Exception as e:\n                    logging.error(f\"Ошибка выполнения команды /music: {e}\")\n            else:\n                logging.warning(f\"Неизвестная команда: {command}\")\n        elif option_action == \"goto\" and option_target:\n            # Переход к узлу\n            target_node_id = option_target\n            try:\n                # Вызываем обработчик для целевого узла\n                if target_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif target_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif target_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif target_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n    else:\n        # Fallback к старой системе next_node_id если нет настроек кнопки\n        next_node_id = config.get(\"next_node_id\")\n        if next_node_id:\n            try:\n                # Вызываем обработчик для следующего узла\n                if next_node_id == \"start-1\":\n                    await handle_callback_start_1(callback_query)\n                elif next_node_id == \"survey-1\":\n                    await handle_callback_survey_1(callback_query)\n                elif next_node_id == \"tech-info\":\n                    await handle_callback_tech_info(callback_query)\n                elif next_node_id == \"music-cmd\":\n                    await handle_callback_music_cmd(callback_query)\n                else:\n                    logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n\n# Универсальный обработчик пользовательского ввода\n@dp.message(F.text)\nasync def handle_user_input(message: types.Message):\n    user_id = message.from_user.id\n    \n    # Проверяем, ожидаем ли мы кнопочный ответ через reply клавиатуру\n    if user_id in user_data and \"button_response_config\" in user_data[user_id]:\n        config = user_data[user_id][\"button_response_config\"]\n        user_text = message.text\n        \n        # Ищем выбранный вариант среди доступных опций\n        selected_option = None\n        for option in config.get(\"options\", []):\n            if option[\"text\"] == user_text:\n                selected_option = option\n                break\n        \n        if selected_option:\n            selected_value = selected_option[\"value\"]\n            selected_text = selected_option[\"text\"]\n            \n            # Сохраняем ответ пользователя\n            variable_name = config.get(\"variable\", \"button_response\")\n            import datetime\n            timestamp = datetime.datetime.now().isoformat()\n            node_id = config.get(\"node_id\", \"unknown\")\n            \n            # Создаем структурированный ответ\n            response_data = {\n                \"value\": selected_value,\n                \"text\": selected_text,\n                \"type\": \"button_choice\",\n                \"timestamp\": timestamp,\n                \"nodeId\": node_id,\n                \"variable\": variable_name\n            }\n            \n            # Сохраняем в пользовательские данные\n            user_data[user_id][variable_name] = response_data\n            \n            # Сохраняем в базу данных если включено\n            if config.get(\"save_to_database\"):\n                saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                if saved_to_db:\n                    logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n                else:\n                    logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n            \n            # Отправляем сообщение об успехе\n            success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n            await message.answer(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=ReplyKeyboardRemove())\n            \n            # Очищаем состояние\n            del user_data[user_id][\"button_response_config\"]\n            \n            logging.info(f\"Получен кнопочный ответ через reply клавиатуру: {variable_name} = {selected_text}\")\n            \n            # Навигация на основе действия кнопки\n            option_action = selected_option.get(\"action\", \"goto\")\n            option_target = selected_option.get(\"target\", \"\")\n            option_url = selected_option.get(\"url\", \"\")\n            \n            if option_action == \"url\" and option_url:\n                # Открытие ссылки\n                url = option_url\n                keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=url)]\n                ])\n                await message.answer(\"Нажмите кнопку ниже, чтобы открыть ссылку:\", reply_markup=keyboard)\n            elif option_action == \"command\" and option_target:\n                # Выполнение команды\n                command = option_target\n                # Создаем фиктивное сообщение для выполнения команды\n                import types as aiogram_types\n                fake_message = aiogram_types.SimpleNamespace(\n                    from_user=message.from_user,\n                    chat=message.chat,\n                    text=command,\n                    message_id=message.message_id\n                )\n                \n                if command == \"/start\":\n                    try:\n                        await start_handler(fake_message)\n                    except Exception as e:\n                        logging.error(f\"Ошибка выполнения команды /start: {e}\")\n                elif command == \"/music\":\n                    try:\n                        await _music_handler(fake_message)\n                    except Exception as e:\n                        logging.error(f\"Ошибка выполнения команды /music: {e}\")\n                else:\n                    logging.warning(f\"Неизвестная команда: {command}\")\n            elif option_action == \"goto\" and option_target:\n                # Переход к узлу\n                target_node_id = option_target\n                try:\n                    # Вызываем обработчик для целевого узла\n                    if target_node_id == \"start-1\":\n                        await handle_callback_start_1(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"survey-1\":\n                        await handle_callback_survey_1(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"tech-info\":\n                        await handle_callback_tech_info(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"music-cmd\":\n                        await handle_callback_music_cmd(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    else:\n                        logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n                except Exception as e:\n                    logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n            else:\n                # Fallback к старой системе next_node_id если нет action\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start-1\":\n                            await handle_callback_start_1(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"survey-1\":\n                            await handle_callback_survey_1(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"tech-info\":\n                            await handle_callback_tech_info(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"music-cmd\":\n                            await handle_callback_music_cmd(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            return\n        else:\n            # Неверный выбор - показываем доступные варианты\n            available_options = [option[\"text\"] for option in config.get(\"options\", [])]\n            options_text = \"\\n\".join([f\"• {opt}\" for opt in available_options])\n            await message.answer(f\"❌ Неверный выбор. Пожалуйста, выберите один из предложенных вариантов:\\n\\n{options_text}\")\n            return\n    \n    # Проверяем, ожидаем ли мы текстовый ввод от пользователя (универсальная система)\n    if user_id in user_data and \"waiting_for_input\" in user_data[user_id]:\n        # Обрабатываем ввод через универсальную систему\n        waiting_node_id = user_data[user_id][\"waiting_for_input\"]\n        input_type = user_data[user_id].get(\"input_type\", \"text\")\n        user_text = message.text\n        \n        # Находим узел для получения настроек\n        \n        # Если узел не найден\n        logging.warning(f\"Узел для сбора ввода не найден: {waiting_node_id}\")\n        del user_data[user_id][\"waiting_for_input\"]\n        return\n    \n    # Если нет активного ожидания ввода, игнорируем сообщение\n    return\n    # Валидация длины текста\n    min_length = input_config.get(\"min_length\", 0)\n    max_length = input_config.get(\"max_length\", 0)\n    \n    if min_length > 0 and len(user_text) < min_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком короткий ответ (минимум {min_length} символов). {retry_message}\")\n        return\n    \n    if max_length > 0 and len(user_text) > max_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком длинный ответ (максимум {max_length} символов). {retry_message}\")\n        return\n    \n    # Валидация типа ввода\n    input_type = input_config.get(\"type\", \"text\")\n    \n    if input_type == \"email\":\n        import re\n        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        if not re.match(email_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат email. {retry_message}\")\n            return\n    \n    elif input_type == \"number\":\n        try:\n            float(user_text)\n        except ValueError:\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Введите корректное число. {retry_message}\")\n            return\n    \n    elif input_type == \"phone\":\n        import re\n        phone_pattern = r\"^[+]?[0-9\\s\\-\\(\\)]{10,}$\"\n        if not re.match(phone_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат телефона. {retry_message}\")\n            return\n    \n    # Сохраняем ответ пользователя в структурированном формате\n    variable_name = input_config.get(\"variable\", \"user_response\")\n    import datetime\n    timestamp = datetime.datetime.now().isoformat()\n    node_id = input_config.get(\"node_id\", \"unknown\")\n    \n    # Создаем структурированный ответ\n    response_data = {\n        \"value\": user_text,\n        \"type\": input_type,\n        \"timestamp\": timestamp,\n        \"nodeId\": node_id,\n        \"prompt\": input_config.get(\"prompt\", \"\"),\n        \"variable\": variable_name\n    }\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if input_config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Данные сохранены в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = input_config.get(\"success_message\", \"Спасибо за ваш ответ!\")\n    await message.answer(success_message)\n    \n    # Очищаем состояние ожидания ввода\n    del user_data[user_id][\"waiting_for_input\"]\n    \n    logging.info(f\"Получен пользовательский ввод: {variable_name} = {user_text}\")\n    \n    # Автоматическая навигация к следующему узлу после успешного ввода\n    next_node_id = input_config.get(\"next_node_id\")\n    logging.info(f\"🔄 Проверяем навигацию: next_node_id = {next_node_id}\")\n    if next_node_id:\n        try:\n            logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n            \n            # Находим узел по ID и выполняем соответствующее действие\n            if next_node_id == \"start-1\":\n                logging.info(f\"Переход к узлу start-1 типа start\")\n            elif next_node_id == \"survey-1\":\n                prompt_text = f\"Что вас интересует?\"\n                \n                # Создаем кнопки для выбора ответа\n                builder = InlineKeyboardBuilder()\n                builder.add(InlineKeyboardButton(text=\"📱 Технологии\", callback_data=\"response_survey-1_0\"))\n                builder.add(InlineKeyboardButton(text=\"🎵 Музыка\", callback_data=\"response_survey-1_1\"))\n                builder.add(InlineKeyboardButton(text=\"🌐 Сайт\", callback_data=\"response_survey-1_2\"))\n                builder.add(InlineKeyboardButton(text=\"🔄 Главное меню\", callback_data=\"response_survey-1_3\"))\n                keyboard = builder.as_markup()\n                await message.answer(prompt_text, reply_markup=keyboard)\n                \n                # Настраиваем конфигурацию кнопочного ответа\n                user_data[user_id][\"button_response_config\"] = {\n                    \"variable\": \"user_interest\",\n                    \"node_id\": \"survey-1\",\n                    \"timeout\": 60,\n                    \"allow_multiple\": False,\n                    \"save_to_database\": True,\n                    \"selected\": [],\n                    \"success_message\": \"Спасибо за ваш ответ!\",\n                    \"prompt\": f\"Что вас интересует?\",\n                    \"options\": [\n                        {\n                            \"text\": \"📱 Технологии\",\n                            \"value\": \"tech\",\n                            \"action\": \"goto\",\n                            \"target\": \"tech-info\",\n                            \"url\": \"\",\n                            \"callback_data\": \"response_survey-1_0\"\n                        },\n                        {\n                            \"text\": \"🎵 Музыка\",\n                            \"value\": \"music\",\n                            \"action\": \"command\",\n                            \"target\": \"/music\",\n                            \"url\": \"\",\n                            \"callback_data\": \"response_survey-1_1\"\n                        },\n                        {\n                            \"text\": \"🌐 Сайт\",\n                            \"value\": \"website\",\n                            \"action\": \"url\",\n                            \"target\": \"\",\n                            \"url\": \"https://example.com\",\n                            \"callback_data\": \"response_survey-1_2\"\n                        },\n                        {\n                            \"text\": \"🔄 Главное меню\",\n                            \"value\": \"menu\",\n                            \"action\": \"goto\",\n                            \"target\": \"start-1\",\n                            \"url\": \"\",\n                            \"callback_data\": \"response_survey-1_3\"\n                        }\n                    ],\n                    \"next_node_id\": \"tech-info\"\n                }\n            elif next_node_id == \"tech-info\":\n                text = f\"🤖 Технологии - это будущее! Вы выбрали отличную тему.\"\n                parse_mode = None\n                builder = InlineKeyboardBuilder()\n                builder.add(InlineKeyboardButton(text=\"Назад к опросу\", callback_data=\"survey-1\"))\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            elif next_node_id == \"music-cmd\":\n                logging.info(f\"Переход к узлу music-cmd типа command\")\n            else:\n                logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n        except Exception as e:\n            logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n\n\n# Запуск бота\nasync def main():\n    global db_pool\n    try:\n        # Инициализируем базу данных\n        await init_database()\n        print(\"🤖 Бот запущен и готов к работе!\")\n        await dp.start_polling(bot)\n    except KeyboardInterrupt:\n        print(\"🛑 Получен сигнал остановки, завершаем работу...\")\n    except Exception as e:\n        logging.error(f\"Критическая ошибка: {e}\")\n    finally:\n        # Правильно закрываем все соединения\n        if db_pool:\n            await db_pool.close()\n            print(\"🔌 Соединение с базой данных закрыто\")\n        \n        # Закрываем сессию бота\n        await bot.session.close()\n        print(\"🔌 Сессия бота закрыта\")\n        print(\"✅ Бот корректно завершил работу\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"}