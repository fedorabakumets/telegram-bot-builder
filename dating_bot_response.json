{"code":"\"\"\"\nПолный бот знакомств - Telegram Bot\nСгенерировано с помощью TelegramBot Builder\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nfrom aiogram import Bot, Dispatcher, types, F\nfrom aiogram.filters import CommandStart, Command\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, BotCommand, ReplyKeyboardRemove, URLInputFile, FSInputFile\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\nfrom aiogram.enums import ParseMode\nfrom typing import Optional\nimport asyncpg\nfrom datetime import datetime, timezone, timedelta\nimport json\n\n# Функция для получения московского времени\ndef get_moscow_time():\n    \"\"\"Возвращает текущее время в московском часовом поясе\"\"\"\n    moscow_tz = timezone(timedelta(hours=3))  # UTC+3 для Москвы\n    return datetime.now(moscow_tz).isoformat()\n\n# Токен вашего бота (получите у @BotFather)\nBOT_TOKEN = \"YOUR_BOT_TOKEN_HERE\"\n\n# Настройка логирования\nlogging.basicConfig(level=logging.INFO)\n\n# Создание бота и диспетчера\nbot = Bot(token=BOT_TOKEN)\ndp = Dispatcher()\n\n# Список администраторов (добавьте свой Telegram ID)\nADMIN_IDS = [123456789]  # Замените на реальные ID администраторов\n\n# Настройки базы данных\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\n\n# Пул соединений с базой данных\ndb_pool = None\n\n# Хранилище пользователей (резервное для случаев без БД)\nuser_data = {}\n\n\n# Функции для работы с базой данных\nasync def init_database():\n    \"\"\"Инициализация подключения к базе данных и создание таблиц\"\"\"\n    global db_pool\n    try:\n        db_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)\n        # Создаем таблицу пользователей если её нет\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS bot_users (\n                    user_id BIGINT PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    registered_at TIMESTAMP DEFAULT NOW(),\n                    last_interaction TIMESTAMP DEFAULT NOW(),\n                    interaction_count INTEGER DEFAULT 0,\n                    user_data JSONB DEFAULT '{}',\n                    is_active BOOLEAN DEFAULT TRUE\n                );\n            \"\"\")\n        logging.info(\"✅ База данных инициализирована\")\n    except Exception as e:\n        logging.warning(f\"⚠️ Не удалось подключиться к БД: {e}. Используем локальное хранилище.\")\n        db_pool = None\n\nasync def save_user_to_db(user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None):\n    \"\"\"Сохраняет пользователя в базу данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id, username, first_name, last_name)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (user_id) DO UPDATE SET\n                    username = EXCLUDED.username,\n                    first_name = EXCLUDED.first_name,\n                    last_name = EXCLUDED.last_name,\n                    last_interaction = NOW(),\n                    interaction_count = bot_users.interaction_count + 1\n            \"\"\", user_id, username, first_name, last_name)\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка сохранения пользователя в БД: {e}\")\n        return False\n\nasync def get_user_from_db(user_id: int):\n    \"\"\"Получает данные пользователя из базы данных\"\"\"\n    if not db_pool:\n        return None\n    try:\n        async with db_pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM bot_users WHERE user_id = $1\", user_id)\n            if row:\n                return dict(row)\n        return None\n    except Exception as e:\n        logging.error(f\"Ошибка получения пользователя из БД: {e}\")\n        return None\n\nasync def update_user_data_in_db(user_id: int, data_key: str, data_value):\n    \"\"\"Обновляет пользовательские данные в базе данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        import json\n        async with db_pool.acquire() as conn:\n            # Сначала создаём или получаем существующую запись\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id) \n                VALUES ($1) \n                ON CONFLICT (user_id) DO NOTHING\n            \"\"\", user_id)\n            \n            # Обновляем данные пользователя\n            update_data = {data_key: data_value}\n            await conn.execute(\"\"\"\n                UPDATE bot_users \n                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,\n                    last_interaction = NOW()\n                WHERE user_id = $1\n            \"\"\", user_id, json.dumps(update_data))\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка обновления данных пользователя: {e}\")\n        return False\n\nasync def update_user_variable_in_db(user_id: int, variable_name: str, variable_value: str):\n    \"\"\"Сохраняет переменную пользователя в базу данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        import json\n        async with db_pool.acquire() as conn:\n            # Сначала создаём или получаем существующую запись\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id) \n                VALUES ($1) \n                ON CONFLICT (user_id) DO NOTHING\n            \"\"\", user_id)\n            \n            # Обновляем переменную пользователя\n            update_data = {variable_name: variable_value}\n            await conn.execute(\"\"\"\n                UPDATE bot_users \n                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,\n                    last_interaction = NOW()\n                WHERE user_id = $1\n            \"\"\", user_id, json.dumps(update_data))\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка сохранения переменной пользователя: {e}\")\n        return False\n\n\n# Утилитарные функции\nasync def is_admin(user_id: int) -> bool:\n    return user_id in ADMIN_IDS\n\nasync def is_private_chat(message: types.Message) -> bool:\n    return message.chat.type == \"private\"\n\nasync def check_auth(user_id: int) -> bool:\n    # Проверяем наличие пользователя в БД или локальном хранилище\n    if db_pool:\n        user = await get_user_from_db(user_id)\n        return user is not None\n    return user_id in user_data\n\ndef is_local_file(url: str) -> bool:\n    \"\"\"Проверяет, является ли URL локальным загруженным файлом\"\"\"\n    return url.startswith(\"/uploads/\") or url.startswith(\"uploads/\")\n\ndef get_local_file_path(url: str) -> str:\n    \"\"\"Получает локальный путь к файлу из URL\"\"\"\n    if url.startswith(\"/\"):\n        return url[1:]  # Убираем ведущий слеш\n    return url\n\ndef extract_coordinates_from_yandex(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Яндекс.Карт\"\"\"\n    import re\n    # Ищем координаты в формате ll=longitude,latitude\n    match = re.search(r\"ll=([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Ищем координаты в формате /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_google(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Google Maps\"\"\"\n    import re\n    # Ищем координаты в формате @latitude,longitude\n    match = re.search(r\"@([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    # Ищем координаты в формате /latitude,longitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_2gis(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки 2ГИС\"\"\"\n    import re\n    # Ищем координаты в различных форматах 2ГИС\n    # Формат: center/longitude,latitude\n    match = re.search(r\"center/([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Формат: /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef generate_map_urls(latitude: float, longitude: float, title: str = \"\") -> dict:\n    \"\"\"Генерирует ссылки на различные картографические сервисы\"\"\"\n    import urllib.parse\n    \n    encoded_title = urllib.parse.quote(title) if title else \"\"\n    \n    return {\n        \"yandex\": f\"https://yandex.ru/maps/?ll={longitude},{latitude}&z=15&l=map&pt={longitude},{latitude}\",\n        \"google\": f\"https://maps.google.com/?q={latitude},{longitude}\",\n        \"2gis\": f\"https://2gis.ru/geo/{longitude},{latitude}\",\n        \"openstreetmap\": f\"https://www.openstreetmap.org/?mlat={latitude}&mlon={longitude}&zoom=15\"\n    }\n\n\n@dp.message(CommandStart())\nasync def start_handler(message: types.Message):\n\n    # Регистрируем пользователя в системе\n    user_id = message.from_user.id\n    username = message.from_user.username\n    first_name = message.from_user.first_name\n    last_name = message.from_user.last_name\n    \n    # Сохраняем пользователя в базу данных\n    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)\n    \n    # Резервное сохранение в локальное хранилище\n    if not saved_to_db:\n        user_data[user_id] = {\n            \"username\": username,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"registered_at\": message.date\n        }\n        logging.info(f\"Пользователь {user_id} сохранен в локальное хранилище\")\n    else:\n        logging.info(f\"Пользователь {user_id} сохранен в базу данных\")\n\n    text = \"🌟 Добро пожаловать в бот знакомств!\\n\\nЗдесь вы сможете найти интересных людей для общения. Заполните анкету для начала.\"\n    # Определяем режим форматирования (приоритет у условного сообщения)\n    if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n        current_parse_mode = conditional_parse_mode\n    else:\n        current_parse_mode = None\n    # Инициализируем переменную для проверки условной клавиатуры\n    use_conditional_keyboard = False\n    conditional_keyboard = None\n    \n    # Проверяем, нужно ли использовать условную клавиатуру\n    if use_conditional_keyboard:\n        await message.answer(text, reply_markup=conditional_keyboard, parse_mode=current_parse_mode if current_parse_mode else None)\n    else:\n        # Создаем inline клавиатуру с кнопками\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"📝 Создать анкету\", callback_data=\"ask_join_chat\"))\n        builder.add(InlineKeyboardButton(text=\"ℹ️ О боте\", callback_data=\"about_info\"))\n        keyboard = builder.as_markup()\n        await message.answer(text, reply_markup=keyboard, parse_mode=current_parse_mode if current_parse_mode else None)\n\n# Обработчики inline кнопок\n\n@dp.callback_query(lambda c: c.data == \"ask_join_chat\" or c.data.startswith(\"ask_join_chat_btn_\"))\nasync def handle_callback_ask_join_chat(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"📝 Создать анкету\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа input: ask_join_chat\n    text = \"💬 Хотите присоединиться к чату знакомств?\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем reply клавиатуру\n        builder = ReplyKeyboardBuilder()\n        builder.add(KeyboardButton(text=\"Да 😎\"))\n        builder.add(KeyboardButton(text=\"Нет 🙅\"))\n        keyboard = builder.as_markup(resize_keyboard=False, one_time_keyboard=False)\n    # Для reply клавиатуры отправляем новое сообщение и удаляем старое\n    try:\n        await callback_query.message.delete()\n    except:\n        pass  # Игнорируем ошибки удаления\n    await bot.send_message(callback_query.from_user.id, text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"about_info\" or c.data.startswith(\"about_info_btn_\"))\nasync def handle_callback_about_info(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"ℹ️ О боте\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Отправляем сообщение для узла about_info\n    text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    \n    # Без условных сообщений - используем обычную клавиатуру\n    keyboard = None\n    # Проверяем, есть ли условная клавиатура\n    if keyboard is None:\n        # Создаем inline клавиатуру для целевого узла\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"📝 Начать регистрацию\", callback_data=\"ask_join_chat_btn_0\"))\n        builder.add(InlineKeyboardButton(text=\"⬅️ Назад\", callback_data=\"start_dating_btn_1\"))\n        keyboard = builder.as_markup()\n    # Отправляем сообщение\n    try:\n        if keyboard is not None:\n            await callback_query.message.edit_text(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.edit_text(text)\n    except Exception:\n        if keyboard is not None:\n            await callback_query.message.answer(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.answer(text)\n\n@dp.callback_query(lambda c: c.data == \"sports_menu\" or c.data.startswith(\"sports_menu_btn_\"))\nasync def handle_callback_sports_menu(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"⚽ Спорт\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа keyboard: sports_menu\n    text = \"⚽ Выберите спортивные интересы:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем inline клавиатуру\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"⬅️ К категориям\", callback_data=\"ask_interests_btn_2\"))\n        keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"culture_menu\" or c.data.startswith(\"culture_menu_btn_\"))\nasync def handle_callback_culture_menu(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"🎨 Культура\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа keyboard: culture_menu\n    text = \"🎨 Выберите культурные интересы:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем inline клавиатуру\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"⬅️ К категориям\", callback_data=\"ask_interests_btn_2\"))\n        keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"profile_complete\" or c.data.startswith(\"profile_complete_btn_\"))\nasync def handle_callback_profile_complete(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"✅ Готово\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Отправляем сообщение для узла profile_complete\n    text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    \n    # Без условных сообщений - используем обычную клавиатуру\n    keyboard = None\n    # Проверяем, есть ли условная клавиатура\n    if keyboard is None:\n        # Создаем inline клавиатуру для целевого узла\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"📝 Моя анкета\", callback_data=\"cmd_profile\"))\n        keyboard = builder.as_markup()\n    # Отправляем сообщение\n    try:\n        if keyboard is not None:\n            await callback_query.message.edit_text(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.edit_text(text)\n    except Exception:\n        if keyboard is not None:\n            await callback_query.message.answer(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.answer(text)\n\n@dp.callback_query(lambda c: c.data == \"ask_interests\" or c.data.startswith(\"ask_interests_btn_\"))\nasync def handle_callback_ask_interests(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"⬅️ К категориям\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа keyboard: ask_interests\n    text = \"🎯 Выберите ваши интересы:\\n\\nМожете выбрать несколько категорий:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем inline клавиатуру\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"⚽ Спорт\", callback_data=\"sports_menu_btn_0\"))\n        builder.add(InlineKeyboardButton(text=\"🎨 Культура\", callback_data=\"culture_menu_btn_1\"))\n        builder.add(InlineKeyboardButton(text=\"✅ Готово\", callback_data=\"profile_complete_btn_2\"))\n        keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"ask_interests\" or c.data.startswith(\"ask_interests_btn_\"))\nasync def handle_callback_ask_interests(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"⬅️ К категориям\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа keyboard: ask_interests\n    text = \"🎯 Выберите ваши интересы:\\n\\nМожете выбрать несколько категорий:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем inline клавиатуру\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"⚽ Спорт\", callback_data=\"sports_menu_btn_0\"))\n        builder.add(InlineKeyboardButton(text=\"🎨 Культура\", callback_data=\"culture_menu_btn_1\"))\n        builder.add(InlineKeyboardButton(text=\"✅ Готово\", callback_data=\"profile_complete_btn_2\"))\n        keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"ask_join_chat\" or c.data.startswith(\"ask_join_chat_btn_\"))\nasync def handle_callback_ask_join_chat(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"📝 Начать регистрацию\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел типа input: ask_join_chat\n    text = \"💬 Хотите присоединиться к чату знакомств?\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Проверяем, есть ли уже клавиатура из условных сообщений\n    if \"keyboard\" not in locals() or keyboard is None:\n        # Создаем reply клавиатуру\n        builder = ReplyKeyboardBuilder()\n        builder.add(KeyboardButton(text=\"Да 😎\"))\n        builder.add(KeyboardButton(text=\"Нет 🙅\"))\n        keyboard = builder.as_markup(resize_keyboard=False, one_time_keyboard=False)\n    # Для reply клавиатуры отправляем новое сообщение и удаляем старое\n    try:\n        await callback_query.message.delete()\n    except:\n        pass  # Игнорируем ошибки удаления\n    await bot.send_message(callback_query.from_user.id, text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"start_dating\" or c.data.startswith(\"start_dating_btn_\"))\nasync def handle_callback_start_dating(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"⬅️ Назад\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Обрабатываем узел start: start_dating\n    text = \"🌟 Добро пожаловать в бот знакомств!\\n\\nЗдесь вы сможете найти интересных людей для общения. Заполните анкету для начала.\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    \n    # Без условных сообщений - используем обычную клавиатуру\n    keyboard = None\n    # Проверяем, есть ли условная клавиатура\n    if keyboard is None:\n        # Создаем inline клавиатуру для start узла\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"📝 Создать анкету\", callback_data=\"ask_join_chat_btn_0\"))\n        builder.add(InlineKeyboardButton(text=\"ℹ️ О боте\", callback_data=\"about_info_btn_1\"))\n        keyboard = builder.as_markup()\n    # Отправляем сообщение start узла\n    try:\n        if keyboard is not None:\n            await callback_query.message.edit_text(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.edit_text(text)\n    except Exception:\n        if keyboard is not None:\n            await callback_query.message.answer(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.answer(text)\n\n@dp.callback_query(lambda c: c.data == \"ask_join_chat\" or c.data.startswith(\"ask_join_chat_btn_\"))\nasync def handle_callback_ask_join_chat(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"📝 Создать анкету\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"ask_join_chat\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"💬 Хотите присоединиться к чату знакомств?\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text)\n\n@dp.callback_query(lambda c: c.data == \"about_info\" or c.data.startswith(\"about_info_btn_\"))\nasync def handle_callback_about_info(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"ℹ️ О боте\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"about_info\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"📝 Начать регистрацию\", callback_data=\"btn_start_reg\"))\n    builder.add(InlineKeyboardButton(text=\"⬅️ Назад\", callback_data=\"btn_back_start\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"sports_menu\" or c.data.startswith(\"sports_menu_btn_\"))\nasync def handle_callback_sports_menu(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"⚽ Спорт\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"sports_menu\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"⚽ Выберите спортивные интересы:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"⚽ Футбол\", callback_data=\"cmd_add_sport_футбол\"))\n    builder.add(InlineKeyboardButton(text=\"🏀 Баскетбол\", callback_data=\"cmd_add_sport_баскетбол\"))\n    builder.add(InlineKeyboardButton(text=\"⬅️ К категориям\", callback_data=\"btn_back_interests_sports\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"culture_menu\" or c.data.startswith(\"culture_menu_btn_\"))\nasync def handle_callback_culture_menu(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"🎨 Культура\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"culture_menu\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"🎨 Выберите культурные интересы:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"🎭 Театр\", callback_data=\"cmd_add_culture_театр\"))\n    builder.add(InlineKeyboardButton(text=\"🎬 Кино\", callback_data=\"cmd_add_culture_кино\"))\n    builder.add(InlineKeyboardButton(text=\"⬅️ К категориям\", callback_data=\"btn_back_interests_culture\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"profile_complete\" or c.data.startswith(\"profile_complete_btn_\"))\nasync def handle_callback_profile_complete(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"✅ Готово\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"profile_complete\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"📝 Моя анкета\", callback_data=\"cmd_profile\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"ask_interests\" or c.data.startswith(\"ask_interests_btn_\"))\nasync def handle_callback_ask_interests(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"⬅️ К категориям\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"ask_interests\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"🎯 Выберите ваши интересы:\\n\\nМожете выбрать несколько категорий:\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"⚽ Спорт\", callback_data=\"btn_sports_category\"))\n    builder.add(InlineKeyboardButton(text=\"🎨 Культура\", callback_data=\"btn_culture_category\"))\n    builder.add(InlineKeyboardButton(text=\"✅ Готово\", callback_data=\"btn_interests_done\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n@dp.callback_query(lambda c: c.data == \"start_dating\" or c.data.startswith(\"start_dating_btn_\"))\nasync def handle_callback_start_dating(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"⬅️ Назад\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"start_dating\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start_dating\":\n            logging.info(\"Переход к узлу start_dating\")\n        elif next_node_id == \"ask_join_chat\":\n            logging.info(\"Переход к узлу ask_join_chat\")\n        elif next_node_id == \"ask_gender\":\n            logging.info(\"Переход к узлу ask_gender\")\n        elif next_node_id == \"ask_name\":\n            logging.info(\"Переход к узлу ask_name\")\n        elif next_node_id == \"ask_interests\":\n            logging.info(\"Переход к узлу ask_interests\")\n        elif next_node_id == \"sports_menu\":\n            logging.info(\"Переход к узлу sports_menu\")\n        elif next_node_id == \"culture_menu\":\n            logging.info(\"Переход к узлу culture_menu\")\n        elif next_node_id == \"profile_complete\":\n            nav_text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"about_info\":\n            nav_text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"🌟 Добро пожаловать в бот знакомств!\\n\\nЗдесь вы сможете найти интересных людей для общения. Заполните анкету для начала.\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    builder.add(InlineKeyboardButton(text=\"📝 Создать анкету\", callback_data=\"btn_create_profile\"))\n    builder.add(InlineKeyboardButton(text=\"ℹ️ О боте\", callback_data=\"btn_about_bot\"))\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n# Обработчики reply кнопок\n\n@dp.message(lambda message: message.text == \"Да 😎\")\nasync def handle_reply_btn_yes_chat(message: types.Message):\n    text = \"👤 Укажите ваш пол:\"\n    user_id = message.from_user.id\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = ReplyKeyboardBuilder()\n    builder.add(KeyboardButton(text=\"Мужчина 👨\"))\n    builder.add(KeyboardButton(text=\"Женщина 👩\"))\n    keyboard = builder.as_markup(resize_keyboard=False, one_time_keyboard=False)\n    await message.answer(text, reply_markup=keyboard)\n    \n    # Сохраняем нажатие reply кнопки если включен сбор ответов\n    user_id = message.from_user.id\n    if user_id in user_data and user_data[user_id].get(\"input_collection_enabled\"):\n        import datetime\n        timestamp = get_moscow_time()\n        input_node_id = user_data[user_id].get(\"input_node_id\")\n        input_variable = user_data[user_id].get(\"input_variable\", \"button_response\")\n        \n        response_data = {\n            \"value\": \"Да 😎\",\n            \"type\": \"reply_button\",\n            \"timestamp\": timestamp,\n            \"nodeId\": input_node_id,\n            \"variable\": input_variable,\n            \"source\": \"reply_button_click\"\n        }\n        \n        user_data[user_id][f\"{input_variable}_button\"] = response_data\n        logging.info(f\"Reply кнопка сохранена: {input_variable}_button = ${buttonText} (пользователь {user_id})\")\n\n@dp.message(lambda message: message.text == \"Нет 🙅\")\nasync def handle_reply_btn_no_chat(message: types.Message):\n    text = \"👤 Укажите ваш пол:\"\n    user_id = message.from_user.id\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = ReplyKeyboardBuilder()\n    builder.add(KeyboardButton(text=\"Мужчина 👨\"))\n    builder.add(KeyboardButton(text=\"Женщина 👩\"))\n    keyboard = builder.as_markup(resize_keyboard=False, one_time_keyboard=False)\n    await message.answer(text, reply_markup=keyboard)\n    \n    # Сохраняем нажатие reply кнопки если включен сбор ответов\n    user_id = message.from_user.id\n    if user_id in user_data and user_data[user_id].get(\"input_collection_enabled\"):\n        import datetime\n        timestamp = get_moscow_time()\n        input_node_id = user_data[user_id].get(\"input_node_id\")\n        input_variable = user_data[user_id].get(\"input_variable\", \"button_response\")\n        \n        response_data = {\n            \"value\": \"Нет 🙅\",\n            \"type\": \"reply_button\",\n            \"timestamp\": timestamp,\n            \"nodeId\": input_node_id,\n            \"variable\": input_variable,\n            \"source\": \"reply_button_click\"\n        }\n        \n        user_data[user_id][f\"{input_variable}_button\"] = response_data\n        logging.info(f\"Reply кнопка сохранена: {input_variable}_button = ${buttonText} (пользователь {user_id})\")\n\n@dp.message(lambda message: message.text == \"Мужчина 👨\")\nasync def handle_reply_btn_male(message: types.Message):\n    text = \"✏️ Как вас зовут?\"\n    user_id = message.from_user.id\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Удаляем предыдущие reply клавиатуры если они были\n    await message.answer(text, reply_markup=ReplyKeyboardRemove())\n\n@dp.message(lambda message: message.text == \"Женщина 👩\")\nasync def handle_reply_btn_female(message: types.Message):\n    text = \"✏️ Как вас зовут?\"\n    user_id = message.from_user.id\n    # Подставляем все доступные переменные пользователя в текст\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Безопасно извлекаем user_data\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Удаляем предыдущие reply клавиатуры если они были\n    await message.answer(text, reply_markup=ReplyKeyboardRemove())\n\n\n# Универсальный обработчик пользовательского ввода\n@dp.message(F.text)\nasync def handle_user_input(message: types.Message):\n    user_id = message.from_user.id\n    \n    # Проверяем, ожидаем ли мы ввод для условного сообщения\n    if user_id in user_data and \"waiting_for_conditional_input\" in user_data[user_id]:\n        config = user_data[user_id][\"waiting_for_conditional_input\"]\n        user_text = message.text\n        \n        # Сохраняем текстовый ввод для условного сообщения\n        condition_id = config.get(\"condition_id\", \"unknown\")\n        next_node_id = config.get(\"next_node_id\")\n        \n        # Сохраняем ответ пользователя\n        timestamp = get_moscow_time()\n        # Используем переменную из конфигурации или создаем автоматическую\n        input_variable = config.get(\"input_variable\", \"\")\n        if input_variable:\n            variable_name = input_variable\n        else:\n            variable_name = f\"conditional_response_{condition_id}\"\n        \n        # Сохраняем в пользовательские данные\n        user_data[user_id][variable_name] = user_text\n        \n        # Сохраняем в базу данных\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, user_text)\n        if saved_to_db:\n            logging.info(f\"✅ Условный ответ сохранен в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n        \n        # Отправляем подтверждение\n        await message.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n        \n        # Очищаем состояние ожидания\n        del user_data[user_id][\"waiting_for_conditional_input\"]\n        \n        logging.info(f\"Получен ответ на условное сообщение: {variable_name} = {user_text}\")\n        \n        # Переходим к следующему узлу если указан\n        if next_node_id:\n            try:\n                logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n                \n                # Проверяем, является ли это командой\n                if next_node_id == \"profile_command\":\n                    logging.info(\"Переход к команде /profile\")\n                    await profile_handler(message)\n                else:\n                    # Создаем фиктивный callback для навигации к обычному узлу\n                    import types as aiogram_types\n                    fake_callback = aiogram_types.SimpleNamespace(\n                        id=\"conditional_nav\",\n                        from_user=message.from_user,\n                        chat_instance=\"\",\n                        data=next_node_id,\n                        message=message,\n                        answer=lambda text=\"\", show_alert=False: asyncio.sleep(0)\n                    )\n                    \n                    if next_node_id == \"start_dating\":\n                        await handle_callback_start_dating(fake_callback)\n                    elif next_node_id == \"ask_join_chat\":\n                        await handle_callback_ask_join_chat(fake_callback)\n                    elif next_node_id == \"ask_gender\":\n                        await handle_callback_ask_gender(fake_callback)\n                    elif next_node_id == \"ask_name\":\n                        await handle_callback_ask_name(fake_callback)\n                    elif next_node_id == \"ask_interests\":\n                        await handle_callback_ask_interests(fake_callback)\n                    elif next_node_id == \"sports_menu\":\n                        await handle_callback_sports_menu(fake_callback)\n                    elif next_node_id == \"culture_menu\":\n                        await handle_callback_culture_menu(fake_callback)\n                    elif next_node_id == \"profile_complete\":\n                        await handle_callback_profile_complete(fake_callback)\n                    elif next_node_id == \"about_info\":\n                        await handle_callback_about_info(fake_callback)\n                    else:\n                        logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n        \n        return  # Завершаем обработку для условного сообщения\n    \n    # Проверяем, ожидаем ли мы кнопочный ответ через reply клавиатуру\n    if user_id in user_data and \"button_response_config\" in user_data[user_id]:\n        config = user_data[user_id][\"button_response_config\"]\n        user_text = message.text\n        \n        # Ищем выбранный вариант среди доступных опций\n        selected_option = None\n        for option in config.get(\"options\", []):\n            if option[\"text\"] == user_text:\n                selected_option = option\n                break\n        \n        if selected_option:\n            selected_value = selected_option[\"value\"]\n            selected_text = selected_option[\"text\"]\n            \n            # Сохраняем ответ пользователя\n            variable_name = config.get(\"variable\", \"button_response\")\n            timestamp = get_moscow_time()\n            node_id = config.get(\"node_id\", \"unknown\")\n            \n            # Создаем структурированный ответ\n            response_data = {\n                \"value\": selected_value,\n                \"text\": selected_text,\n                \"type\": \"button_choice\",\n                \"timestamp\": timestamp,\n                \"nodeId\": node_id,\n                \"variable\": variable_name\n            }\n            \n            # Сохраняем в пользовательские данные\n            user_data[user_id][variable_name] = response_data\n            \n            # Сохраняем в базу данных если включено\n            if config.get(\"save_to_database\"):\n                saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                if saved_to_db:\n                    logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n                else:\n                    logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n            \n            # Отправляем сообщение об успехе\n            success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n            await message.answer(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=ReplyKeyboardRemove())\n            \n            # Очищаем состояние\n            del user_data[user_id][\"button_response_config\"]\n            \n            logging.info(f\"Получен кнопочный ответ через reply клавиатуру: {variable_name} = {selected_text}\")\n            \n            # Навигация на основе действия кнопки\n            option_action = selected_option.get(\"action\", \"goto\")\n            option_target = selected_option.get(\"target\", \"\")\n            option_url = selected_option.get(\"url\", \"\")\n            \n            if option_action == \"url\" and option_url:\n                # Открытие ссылки\n                url = option_url\n                keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=url)]\n                ])\n                await message.answer(\"Нажмите кнопку ниже, чтобы открыть ссылку:\", reply_markup=keyboard)\n            elif option_action == \"command\" and option_target:\n                # Выполнение команды\n                command = option_target\n                # Создаем фиктивное сообщение для выполнения команды\n                import types as aiogram_types\n                fake_message = aiogram_types.SimpleNamespace(\n                    from_user=message.from_user,\n                    chat=message.chat,\n                    text=command,\n                    message_id=message.message_id\n                )\n                \n                if command == \"/start\":\n                    try:\n                        await start_handler(fake_message)\n                    except Exception as e:\n                        logging.error(f\"Ошибка выполнения команды /start: {e}\")\n                else:\n                    logging.warning(f\"Неизвестная команда: {command}\")\n            elif option_action == \"goto\" and option_target:\n                # Переход к узлу\n                target_node_id = option_target\n                try:\n                    # Вызываем обработчик для целевого узла\n                    if target_node_id == \"start_dating\":\n                        await handle_callback_start_dating(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"ask_join_chat\":\n                        await handle_callback_ask_join_chat(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"ask_gender\":\n                        await handle_callback_ask_gender(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"ask_name\":\n                        await handle_callback_ask_name(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"ask_interests\":\n                        await handle_callback_ask_interests(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"sports_menu\":\n                        await handle_callback_sports_menu(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"culture_menu\":\n                        await handle_callback_culture_menu(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"profile_complete\":\n                        await handle_callback_profile_complete(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"about_info\":\n                        await handle_callback_about_info(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    else:\n                        logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n                except Exception as e:\n                    logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n            else:\n                # Fallback к старой системе next_node_id если нет action\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start_dating\":\n                            await handle_callback_start_dating(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"ask_join_chat\":\n                            await handle_callback_ask_join_chat(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"ask_gender\":\n                            await handle_callback_ask_gender(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"ask_name\":\n                            await handle_callback_ask_name(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"ask_interests\":\n                            await handle_callback_ask_interests(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"sports_menu\":\n                            await handle_callback_sports_menu(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"culture_menu\":\n                            await handle_callback_culture_menu(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"profile_complete\":\n                            await handle_callback_profile_complete(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"about_info\":\n                            await handle_callback_about_info(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            return\n        else:\n            # Неверный выбор - показываем доступные варианты\n            available_options = [option[\"text\"] for option in config.get(\"options\", [])]\n            options_text = \"\\n\".join([f\"• {opt}\" for opt in available_options])\n            await message.answer(f\"❌ Неверный выбор. Пожалуйста, выберите один из предложенных вариантов:\\n\\n{options_text}\")\n            return\n    \n    # Проверяем, ожидаем ли мы текстовый ввод от пользователя (универсальная система)\n    if user_id in user_data and \"waiting_for_input\" in user_data[user_id]:\n        # Обрабатываем ввод через универсальную систему\n        waiting_config = user_data[user_id][\"waiting_for_input\"]\n        \n        # Проверяем формат конфигурации - новый (словарь) или старый (строка)\n        if isinstance(waiting_config, dict):\n            # Новый формат - извлекаем данные из словаря\n            waiting_node_id = waiting_config.get(\"node_id\")\n            input_type = waiting_config.get(\"type\", \"text\")\n            variable_name = waiting_config.get(\"variable\", \"user_response\")\n            save_to_database = waiting_config.get(\"save_to_database\", False)\n            min_length = waiting_config.get(\"min_length\", 0)\n            max_length = waiting_config.get(\"max_length\", 0)\n            next_node_id = waiting_config.get(\"next_node_id\")\n        else:\n            # Старый формат - waiting_config это строка с node_id\n            waiting_node_id = waiting_config\n            input_type = user_data[user_id].get(\"input_type\", \"text\")\n            variable_name = user_data[user_id].get(\"input_variable\", \"user_response\")\n            save_to_database = user_data[user_id].get(\"save_to_database\", False)\n            min_length = 0\n            max_length = 0\n            next_node_id = user_data[user_id].get(\"input_target_node_id\")\n        \n        user_text = message.text\n        \n        # Валидация для нового формата\n        if isinstance(waiting_config, dict):\n            # Валидация длины\n            if min_length > 0 and len(user_text) < min_length:\n                retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                await message.answer(f\"❌ Слишком короткий ответ (минимум {min_length} символов). {retry_message}\")\n                return\n            \n            if max_length > 0 and len(user_text) > max_length:\n                retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                await message.answer(f\"❌ Слишком длинный ответ (максимум {max_length} символов). {retry_message}\")\n                return\n            \n            # Валидация типа ввода\n            if input_type == \"email\":\n                import re\n                email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n                if not re.match(email_pattern, user_text):\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Неверный формат email. {retry_message}\")\n                    return\n            elif input_type == \"number\":\n                try:\n                    float(user_text)\n                except ValueError:\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Введите корректное число. {retry_message}\")\n                    return\n            elif input_type == \"phone\":\n                import re\n                phone_pattern = r\"^[+]?[0-9\\s\\-\\(\\)]{10,}$\"\n                if not re.match(phone_pattern, user_text):\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Неверный формат телефона. {retry_message}\")\n                    return\n            \n            # Сохраняем ответ для нового формата\n            timestamp = get_moscow_time()\n            response_data = user_text\n            \n            # Сохраняем в пользовательские данные\n            user_data[user_id][variable_name] = response_data\n            \n            # Сохраняем в базу данных если включено\n            if save_to_database:\n                saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                if saved_to_db:\n                    logging.info(f\"✅ Данные сохранены в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n                else:\n                    logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n            \n            # Отправляем сообщение об успехе\n            success_message = waiting_config.get(\"success_message\", \"Спасибо за ваш ответ!\")\n            await message.answer(success_message)\n            \n            # Очищаем состояние ожидания ввода\n            del user_data[user_id][\"waiting_for_input\"]\n            \n            logging.info(f\"Получен пользовательский ввод: {variable_name} = {user_text}\")\n            \n            # Навигация к следующему узлу для нового формата\n            if next_node_id:\n                try:\n                    logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n                    if next_node_id == \"start_dating\":\n                        logging.info(f\"Переход к узлу start_dating типа start\")\n                    elif next_node_id == \"ask_join_chat\":\n                        logging.info(f\"Переход к узлу ask_join_chat типа input\")\n                    elif next_node_id == \"ask_gender\":\n                        logging.info(f\"Переход к узлу ask_gender типа input\")\n                    elif next_node_id == \"ask_name\":\n                        logging.info(f\"Переход к узлу ask_name типа input\")\n                    elif next_node_id == \"ask_interests\":\n                        logging.info(f\"Переход к узлу ask_interests типа keyboard\")\n                    elif next_node_id == \"sports_menu\":\n                        logging.info(f\"Переход к узлу sports_menu типа keyboard\")\n                    elif next_node_id == \"culture_menu\":\n                        logging.info(f\"Переход к узлу culture_menu типа keyboard\")\n                    elif next_node_id == \"profile_complete\":\n                        text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n                        await message.answer(text)\n                    elif next_node_id == \"about_info\":\n                        text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n                        await message.answer(text)\n                    else:\n                        logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                except Exception as e:\n                    logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            \n            return  # Завершаем обработку для нового формата\n        \n        # Обработка старого формата (для совместимости)\n        # Находим узел для получения настроек\n        \n        # Если узел не найден\n        logging.warning(f\"Узел для сбора ввода не найден: {waiting_node_id}\")\n        del user_data[user_id][\"waiting_for_input\"]\n        return\n    \n    # НОВАЯ ЛОГИКА: Проверяем, включен ли дополнительный сбор ответов для обычных кнопок\n    if user_id in user_data and user_data[user_id].get(\"input_collection_enabled\"):\n        input_node_id = user_data[user_id].get(\"input_node_id\")\n        input_variable = user_data[user_id].get(\"input_variable\", \"button_response\")\n        user_text = message.text\n        \n        # Сохраняем любой текст как дополнительный ответ\n        timestamp = get_moscow_time()\n        \n        response_data = user_text  # Простое значение\n        \n        # Сохраняем в пользовательские данные\n        user_data[user_id][f\"{input_variable}_additional\"] = response_data\n        \n        # Уведомляем пользователя\n        await message.answer(\"✅ Дополнительный комментарий сохранен!\")\n        \n        logging.info(f\"Дополнительный текстовый ввод: {input_variable}_additional = {user_text} (пользователь {user_id})\")\n        return\n    \n    # Если нет активного ожидания ввода, игнорируем сообщение\n    return\n    # Валидация длины текста\n    min_length = input_config.get(\"min_length\", 0)\n    max_length = input_config.get(\"max_length\", 0)\n    \n    if min_length > 0 and len(user_text) < min_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком короткий ответ (минимум {min_length} символов). {retry_message}\")\n        return\n    \n    if max_length > 0 and len(user_text) > max_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком длинный ответ (максимум {max_length} символов). {retry_message}\")\n        return\n    \n    # Валидация типа ввода\n    input_type = input_config.get(\"type\", \"text\")\n    \n    if input_type == \"email\":\n        import re\n        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        if not re.match(email_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат email. {retry_message}\")\n            return\n    \n    elif input_type == \"number\":\n        try:\n            float(user_text)\n        except ValueError:\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Введите корректное число. {retry_message}\")\n            return\n    \n    elif input_type == \"phone\":\n        import re\n        phone_pattern = r\"^[+]?[0-9\\s\\-\\(\\)]{10,}$\"\n        if not re.match(phone_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат телефона. {retry_message}\")\n            return\n    \n    # Сохраняем ответ пользователя простым значением\n    variable_name = input_config.get(\"variable\", \"user_response\")\n    timestamp = get_moscow_time()\n    node_id = input_config.get(\"node_id\", \"unknown\")\n    \n    # Простое значение вместо сложного объекта\n    response_data = user_text\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if input_config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Данные сохранены в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = input_config.get(\"success_message\", \"Спасибо за ваш ответ!\")\n    await message.answer(success_message)\n    \n    # Очищаем состояние ожидания ввода\n    del user_data[user_id][\"waiting_for_input\"]\n    \n    logging.info(f\"Получен пользовательский ввод: {variable_name} = {user_text}\")\n    \n    # Автоматическая навигация к следующему узлу после успешного ввода\n    next_node_id = input_config.get(\"next_node_id\")\n    logging.info(f\"🔄 Проверяем навигацию: next_node_id = {next_node_id}\")\n    if next_node_id:\n        try:\n            logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n            \n            # Находим узел по ID и выполняем соответствующее действие\n            if next_node_id == \"start_dating\":\n                logging.info(f\"Переход к узлу start_dating типа start\")\n            elif next_node_id == \"ask_join_chat\":\n                logging.info(f\"Переход к узлу ask_join_chat типа input\")\n            elif next_node_id == \"ask_gender\":\n                logging.info(f\"Переход к узлу ask_gender типа input\")\n            elif next_node_id == \"ask_name\":\n                logging.info(f\"Переход к узлу ask_name типа input\")\n            elif next_node_id == \"ask_interests\":\n                logging.info(f\"Переход к узлу ask_interests типа keyboard\")\n            elif next_node_id == \"sports_menu\":\n                logging.info(f\"Переход к узлу sports_menu типа keyboard\")\n            elif next_node_id == \"culture_menu\":\n                logging.info(f\"Переход к узлу culture_menu типа keyboard\")\n            elif next_node_id == \"profile_complete\":\n                text = \"🎉 Отлично! Ваша анкета заполнена!\\n\\n📊 Ваш профиль:\\n👤 Имя: {имя}\\n👫 Пол: {пол}\\n💬 Чат: {хочет_в_чат}\\n\\nТеперь можете искать знакомства!\"\n                # Используем parse_mode условного сообщения если он установлен\n                if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n                    parse_mode = conditional_parse_mode\n                else:\n                    parse_mode = None\n                builder = InlineKeyboardBuilder()\n                builder.add(InlineKeyboardButton(text=\"📝 Моя анкета\", callback_data=\"cmd_profile\"))\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            elif next_node_id == \"about_info\":\n                text = \"ℹ️ О боте знакомств\\n\\nЭтот бот поможет вам:\\n• Создать детальную анкету\\n• Найти людей с общими интересами\\n• Познакомиться с новыми друзьями\\n\\n👥 Присоединяйтесь!\"\n                # Используем parse_mode условного сообщения если он установлен\n                if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n                    parse_mode = conditional_parse_mode\n                else:\n                    parse_mode = None\n                builder = InlineKeyboardBuilder()\n                builder.add(InlineKeyboardButton(text=\"📝 Начать регистрацию\", callback_data=\"ask_join_chat\"))\n                builder.add(InlineKeyboardButton(text=\"⬅️ Назад\", callback_data=\"start_dating\"))\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            else:\n                logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n        except Exception as e:\n            logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n\n# Обработчик для условных кнопок\n@dp.callback_query(lambda c: c.data.startswith(\"conditional_\"))\nasync def handle_conditional_button(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    \n    # Парсим callback_data: conditional_variableName_value\n    callback_parts = callback_query.data.split(\"_\", 2)\n    if len(callback_parts) >= 3:\n        variable_name = callback_parts[1]\n        variable_value = callback_parts[2]\n        \n        user_id = callback_query.from_user.id\n        \n        # Сохраняем значение в базу данных\n        await update_user_data_in_db(user_id, variable_name, variable_value)\n        \n        # Сохраняем в локальные данные\n        if user_id not in user_data:\n            user_data[user_id] = {}\n        user_data[user_id][variable_name] = variable_value\n        \n        logging.info(f\"Условная кнопка: {variable_name} = {variable_value} (пользователь {user_id})\")\n        \n        # После обновления значения автоматически вызываем профиль\n        await callback_query.answer(f\"✅ {variable_name} обновлено\")\n        \n        # Создаем имитацию сообщения для вызова команды профиль\n        class FakeMessage:\n            def __init__(self, callback_query):\n                self.from_user = callback_query.from_user\n                self.chat = callback_query.message.chat\n                self.date = callback_query.message.date\n                self.message_id = callback_query.message.message_id\n            \n            async def answer(self, text, parse_mode=None, reply_markup=None):\n                if reply_markup:\n                    await bot.send_message(self.chat.id, text, parse_mode=parse_mode, reply_markup=reply_markup)\n                else:\n                    await bot.send_message(self.chat.id, text, parse_mode=parse_mode)\n            \n            async def edit_text(self, text, parse_mode=None, reply_markup=None):\n                try:\n                    await bot.edit_message_text(text, self.chat.id, self.message_id, parse_mode=parse_mode, reply_markup=reply_markup)\n                except Exception:\n                    await self.answer(text, parse_mode, reply_markup)\n        \n        fake_message = FakeMessage(callback_query)\n        \n        # Вызываем обработчик профиля\n        try:\n            await profile_handler(fake_message)\n        except Exception as e:\n            logging.error(f\"Ошибка вызова profile_handler: {e}\")\n            await callback_query.message.answer(f\"✅ Значение {variable_name} обновлено на: {variable_value}\")\n    else:\n        logging.warning(f\"Неверный формат условной кнопки: {callback_query.data}\")\n        await callback_query.answer(\"❌ Ошибка обработки кнопки\", show_alert=True)\n\n\n# Обработчики для кнопок команд\n\n@dp.callback_query(lambda c: c.data == \"cmd_add_sport_футбол\")\nasync def handle_cmd_add_sport_футбол(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Симулируем выполнение команды /add_sport_футбол\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    await callback_query.message.answer(\"Команда /add_sport_футбол выполнена\")\n    logging.info(f\"Команда /add_sport_футбол выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n@dp.callback_query(lambda c: c.data == \"cmd_add_sport_баскетбол\")\nasync def handle_cmd_add_sport_баскетбол(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Симулируем выполнение команды /add_sport_баскетбол\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    await callback_query.message.answer(\"Команда /add_sport_баскетбол выполнена\")\n    logging.info(f\"Команда /add_sport_баскетбол выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n@dp.callback_query(lambda c: c.data == \"cmd_add_culture_театр\")\nasync def handle_cmd_add_culture_театр(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Симулируем выполнение команды /add_culture_театр\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    await callback_query.message.answer(\"Команда /add_culture_театр выполнена\")\n    logging.info(f\"Команда /add_culture_театр выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n@dp.callback_query(lambda c: c.data == \"cmd_add_culture_кино\")\nasync def handle_cmd_add_culture_кино(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Симулируем выполнение команды /add_culture_кино\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    await callback_query.message.answer(\"Команда /add_culture_кино выполнена\")\n    logging.info(f\"Команда /add_culture_кино выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n@dp.callback_query(lambda c: c.data == \"cmd_profile\")\nasync def handle_cmd_profile(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Симулируем выполнение команды /profile\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    await callback_query.message.answer(\"Команда /profile выполнена\")\n    logging.info(f\"Команда /profile выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n\n# Запуск бота\nasync def main():\n    global db_pool\n    try:\n        # Инициализируем базу данных\n        await init_database()\n        print(\"🤖 Бот запущен и готов к работе!\")\n        await dp.start_polling(bot)\n    except KeyboardInterrupt:\n        print(\"🛑 Получен сигнал остановки, завершаем работу...\")\n    except Exception as e:\n        logging.error(f\"Критическая ошибка: {e}\")\n    finally:\n        # Правильно закрываем все соединения\n        if db_pool:\n            await db_pool.close()\n            print(\"🔌 Соединение с базой данных закрыто\")\n        \n        # Закрываем сессию бота\n        await bot.session.close()\n        print(\"🔌 Сессия бота закрыта\")\n        print(\"✅ Бот корректно завершил работу\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"}