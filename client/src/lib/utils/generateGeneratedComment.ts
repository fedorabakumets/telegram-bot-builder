/**
 * Утилита для автоматического добавления комментариев о генерации кода
 * Помогает отслеживать, какие части кода были сгенерированы автоматически
 */

// Глобальная настройка для включения/отключения генерации комментариев
let commentsEnabled = true;

/**
 * Включает или отключает генерацию комментариев
 * @param enabled - true для включения, false для отключения
 */
export function setCommentsEnabled(enabled: boolean): void {
  commentsEnabled = enabled;
}

/**
 * Возвращает текущее состояние генерации комментариев
 * @returns true если генерация комментариев включена, иначе false
 */
export function areCommentsEnabled(): boolean {
  return commentsEnabled;
}

/**
 * Добавляет комментарий о том, что код сгенерирован в определённом файле
 * @param code - Строка кода, к которой нужно добавить комментарий
 * @param generatorFile - Имя файла-генератора
 * @param additionalInfo - Дополнительная информация для комментария
 * @returns Строку с добавленным комментарием
 */
export function addGeneratedComment(
  code: string,
  generatorFile: string,
  additionalInfo?: string
): string {
  if (!areCommentsEnabled()) {
    return code;
  }

  const baseComment = `# Код сгенерирован в ${generatorFile}`;
  const fullComment = additionalInfo
    ? `${baseComment}: ${additionalInfo}`
    : baseComment;

  return `${fullComment}\n${code}`;
}

/**
 * Создаёт комментарий для блока проверок безопасности
 * @param checkType - Тип проверки ('private_chat', 'admin', 'auth')
 * @returns Комментарий для соответствующей проверки
 */
export function getSecurityCheckComment(checkType: 'private_chat' | 'admin' | 'auth'): string {
  if (!areCommentsEnabled()) {
    return '';
  }

  const comments = {
    private_chat: 'Проверка приватного чата (сгенерировано в generateCommandHandler.ts)',
    admin: 'Проверка прав администратора (сгенерировано в generateCommandHandler.ts)',
    auth: 'Проверка авторизации (сгенерировано в generateCommandHandler.ts)'
  };

  return comments[checkType];
}

/**
 * Создаёт комментарий для блока сохранения пользовательских данных
 * @param dataType - Тип данных ('user_data', 'statistics', 'local_storage')
 * @returns Комментарий для соответствующего блока
 */
export function getDataSavingComment(dataType: 'user_data' | 'statistics' | 'local_storage'): string {
  if (!areCommentsEnabled()) {
    return '';
  }

  const comments = {
    user_data: 'Сохранение пользователя и статистики (сгенерировано в generateCommandHandler.ts)',
    statistics: 'Обновление статистики команд (сгенерировано в generateCommandHandler.ts)',
    local_storage: 'Сохранение в локальное хранилище (сгенерировано в generateCommandHandler.ts)'
  };

  return comments[dataType];
}

/**
 * Создаёт комментарий для блока обработки сообщений
 * @param messageType - Тип сообщения ('conditional', 'fallback', 'keyboard')
 * @returns Комментарий для соответствующего блока
 */
export function getMessageProcessingComment(messageType: 'conditional' | 'fallback' | 'keyboard'): string {
  if (!areCommentsEnabled()) {
    return '';
  }

  const comments = {
    conditional: 'Обработка условных сообщений (сгенерировано в generateCommandHandler.ts)',
    fallback: 'Обработка запасного сообщения (сгенерировано в generateCommandHandler.ts)',
    keyboard: 'Генерация клавиатуры (сгенерировано в generateCommandHandler.ts)'
  };

  return comments[messageType];
}

/**
 * Автоматически добавляет комментарий о генерации к любому блоку кода
 * @param code - Строка кода, к которой нужно добавить комментарий
 * @param generatorFile - Имя файла-генератора
 * @param blockDescription - Описание блока кода (опционально)
 * @returns Строку с добавленным комментарием
 */
export function autoGenerated(
  code: string,
  generatorFile: string,
  blockDescription?: string
): string {
  if (!areCommentsEnabled()) {
    return code;
  }

  const baseComment = `# Код сгенерирован в ${generatorFile}`;
  const fullComment = blockDescription
    ? `${baseComment}: ${blockDescription}`
    : baseComment;

  return `${fullComment}\n${code}`;
}

/**
 * Создаёт обёртку для кода с комментариями о генерации
 * @param codeLines - Массив строк кода
 * @param generatorFile - Имя файла-генератора
 * @param blockDescription - Описание блока
 * @returns Массив строк с добавленными комментариями
 */
export function wrapWithGeneratedComments(
  codeLines: string[],
  generatorFile: string,
  blockDescription?: string
): string[] {
  if (!areCommentsEnabled()) {
    return codeLines;
  }

  const wrappedLines: string[] = [];

  // Добавляем комментарий только если это не пустая строка и не комментарий
  if (codeLines.some(line => line.trim() && !line.trim().startsWith('#'))) {
    wrappedLines.push(`# Код сгенерирован в ${generatorFile}${blockDescription ? `: ${blockDescription}` : ''}`);
  }

  wrappedLines.push(...codeLines);
  return wrappedLines;
}

/**
 * Создаёт блок кода с автоматическими комментариями о генерации
 * @param code - Блок кода
 * @param generatorFile - Имя файла-генератора
 * @param blockDescription - Описание блока
 * @returns Блок кода с комментариями
 */
export function createGeneratedBlock(
  code: string,
  generatorFile: string,
  blockDescription?: string
): string {
  if (!areCommentsEnabled()) {
    return code;
  }

  const lines = code.split('\n').filter(line => line.trim());

  if (lines.length === 0) {
    return '';
  }

  // Если первая строка уже комментарий о генерации, не добавляем повторно
  if (lines[0].includes('Код сгенерирован в')) {
    return code;
  }

  return wrapWithGeneratedComments([code], generatorFile, blockDescription).join('\n');
}

/**
 * Обрабатывает массив строк кода и автоматически добавляет комментарии к непустым блокам
 * @param codeLines - Массив строк кода
 * @param generatorFile - Имя файла-генератора
 * @returns Обработанный массив с комментариями
 */
export function processCodeWithAutoComments(
  codeLines: string[],
  generatorFile: string
): string[] {
  if (!areCommentsEnabled()) {
    return codeLines;
  }

  const result: string[] = [];
  let currentBlock: string[] = [];

  const flushBlock = () => {
    if (currentBlock.length > 0) {
      // Проверяем, содержит ли блок реальный код (не только комментарии и пустые строки)
      const hasRealCode = currentBlock.some(line =>
        line.trim() &&
        !line.trim().startsWith('#') &&
        !line.trim().startsWith('"""') &&
        !line.trim().startsWith("'''")
      );

      if (hasRealCode) {
        // Проверяем, есть ли уже комментарий о генерации в начале блока
        const firstNonEmptyLine = currentBlock.find(line => line.trim());
        if (!firstNonEmptyLine?.includes('Код сгенерирован в')) {
          result.push(`# Код сгенерирован в ${generatorFile}`);
        }
      }

      result.push(...currentBlock);
      currentBlock = [];
    }
  };

  for (let i = 0; i < codeLines.length; i++) {
    const line = codeLines[i];

    // Если строка пустая, добавляем её и продолжаем
    if (!line.trim()) {
      currentBlock.push(line);
      continue;
    }

    // Если строка содержит только комментарий о генерации, пропускаем добавление дубликата
    if (line.includes('Код сгенерирован в')) {
      currentBlock.push(line);
      continue;
    }

    // Если строка начинает новый блок (декоратор, функция, условие), завершаем предыдущий
    if (line.trim().startsWith('@') ||
        line.trim().startsWith('async def') ||
        line.trim().startsWith('def ') ||
        line.trim().startsWith('if ') && currentBlock.length > 0) {
      flushBlock();
    }

    currentBlock.push(line);
  }

  // Обрабатываем последний блок
  flushBlock();

  return result;
}