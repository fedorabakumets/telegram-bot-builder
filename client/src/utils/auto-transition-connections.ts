import { Node, Connection } from '@shared/schema';
import { nanoid } from 'nanoid';

/**
 * Генерирует автоматические соединения для узлов с autoTransitionTo
 * @param nodes - Массив всех узлов
 * @param existingConnections - Существующие соединения (будут отфильтрованы автогенерированные)
 * @returns Объединенный массив: ручные соединения + новые автогенерированные
 */
export function generateAutoTransitionConnections(
  nodes: Node[],
  existingConnections: Connection[]
): Connection[] {
  const manualConnections = existingConnections.filter(c => !c.isAutoGenerated);
  
  const autoConnections: Connection[] = [];

  for (const node of nodes) {
    if (node.data.autoTransitionTo) {
      const targetNode = nodes.find(n => n.id === node.data.autoTransitionTo);
      
      if (targetNode) {
        const existingAuto = manualConnections.find(
          c => c.source === node.id && c.target === node.data.autoTransitionTo && !c.isAutoGenerated
        );

        if (!existingAuto) {
          autoConnections.push({
            id: `auto-${node.id}-${node.data.autoTransitionTo}`,
            source: node.id,
            target: node.data.autoTransitionTo,
            isAutoGenerated: true,
            isInterSheet: false,
          });
        }
      }
    }
  }

  return [...manualConnections, ...autoConnections];
}

/**
 * Удаляет все автоматически сгенерированные соединения
 * @param connections - Массив соединений
 * @returns Только ручные соединения
 */
export function removeAutoGeneratedConnections(connections: Connection[]): Connection[] {
  return connections.filter(c => !c.isAutoGenerated);
}

/**
 * Проверяет, есть ли у узла автопереход и валиден ли он
 * @param node - Узел для проверки
 * @param allNodes - Все узлы для проверки существования целевого узла
 * @returns true, если автопереход валиден
 */
export function hasValidAutoTransition(node: Node, allNodes: Node[]): boolean {
  if (!node.data.autoTransitionTo) {
    return false;
  }
  
  const targetNode = allNodes.find(n => n.id === node.data.autoTransitionTo);
  return !!targetNode;
}
