{"code":"\"\"\"\nМой первый бот - Telegram Bot\nСгенерировано с помощью TelegramBot Builder\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nfrom aiogram import Bot, Dispatcher, types, F\nfrom aiogram.filters import CommandStart, Command\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, BotCommand, ReplyKeyboardRemove, URLInputFile, FSInputFile\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\nfrom aiogram.enums import ParseMode\nfrom typing import Optional\nimport asyncpg\nfrom datetime import datetime, timezone, timedelta\nimport json\n\n# Функция для получения московского времени\ndef get_moscow_time():\n    \"\"\"Возвращает текущее время в московском часовом поясе\"\"\"\n    moscow_tz = timezone(timedelta(hours=3))  # UTC+3 для Москвы\n    return datetime.now(moscow_tz).isoformat()\n\n# Токен вашего бота (получите у @BotFather)\nBOT_TOKEN = \"YOUR_BOT_TOKEN_HERE\"\n\n# Настройка логирования\nlogging.basicConfig(level=logging.INFO)\n\n# Создание бота и диспетчера\nbot = Bot(token=BOT_TOKEN)\ndp = Dispatcher()\n\n# Список администраторов (добавьте свой Telegram ID)\nADMIN_IDS = [123456789]  # Замените на реальные ID администраторов\n\n# Настройки базы данных\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\n\n# Пул соединений с базой данных\ndb_pool = None\n\n# Хранилище пользователей (резервное для случаев без БД)\nuser_data = {}\n\n\n# Функции для работы с базой данных\nasync def init_database():\n    \"\"\"Инициализация подключения к базе данных и создание таблиц\"\"\"\n    global db_pool\n    try:\n        db_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)\n        # Создаем таблицу пользователей если её нет\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS bot_users (\n                    user_id BIGINT PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    registered_at TIMESTAMP DEFAULT NOW(),\n                    last_interaction TIMESTAMP DEFAULT NOW(),\n                    interaction_count INTEGER DEFAULT 0,\n                    user_data JSONB DEFAULT '{}',\n                    is_active BOOLEAN DEFAULT TRUE\n                );\n            \"\"\")\n        logging.info(\"✅ База данных инициализирована\")\n    except Exception as e:\n        logging.warning(f\"⚠️ Не удалось подключиться к БД: {e}. Используем локальное хранилище.\")\n        db_pool = None\n\nasync def save_user_to_db(user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None):\n    \"\"\"Сохраняет пользователя в базу данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        async with db_pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id, username, first_name, last_name)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (user_id) DO UPDATE SET\n                    username = EXCLUDED.username,\n                    first_name = EXCLUDED.first_name,\n                    last_name = EXCLUDED.last_name,\n                    last_interaction = NOW(),\n                    interaction_count = bot_users.interaction_count + 1\n            \"\"\", user_id, username, first_name, last_name)\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка сохранения пользователя в БД: {e}\")\n        return False\n\nasync def get_user_from_db(user_id: int):\n    \"\"\"Получает данные пользователя из базы данных\"\"\"\n    if not db_pool:\n        return None\n    try:\n        async with db_pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM bot_users WHERE user_id = $1\", user_id)\n            if row:\n                # Преобразуем Record в словарь\n                row_dict = {key: row[key] for key in row.keys()}\n                # Если есть user_data, возвращаем его содержимое\n                if \"user_data\" in row_dict and row_dict[\"user_data\"]:\n                    user_data = row_dict[\"user_data\"]\n                    if isinstance(user_data, str):\n                        try:\n                            import json\n                            return json.loads(user_data)\n                        except (json.JSONDecodeError, TypeError):\n                            return {}\n                    elif isinstance(user_data, dict):\n                        return user_data\n                    else:\n                        return {}\n                # Если нет user_data, возвращаем полную запись\n                return row_dict\n        return None\n    except Exception as e:\n        logging.error(f\"Ошибка получения пользователя из БД: {e}\")\n        return None\n\nasync def update_user_data_in_db(user_id: int, data_key: str, data_value):\n    \"\"\"Обновляет пользовательские данные в базе данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        import json\n        async with db_pool.acquire() as conn:\n            # Сначала создаём или получаем существующую запись\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id) \n                VALUES ($1) \n                ON CONFLICT (user_id) DO NOTHING\n            \"\"\", user_id)\n            \n            # Обновляем данные пользователя\n            update_data = {data_key: data_value}\n            await conn.execute(\"\"\"\n                UPDATE bot_users \n                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,\n                    last_interaction = NOW()\n                WHERE user_id = $1\n            \"\"\", user_id, json.dumps(update_data))\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка обновления данных пользователя: {e}\")\n        return False\n\nasync def save_user_data_to_db(user_id: int, data_key: str, data_value):\n    \"\"\"Алиас для update_user_data_in_db для обратной совместимости\"\"\"\n    return await update_user_data_in_db(user_id, data_key, data_value)\n\nasync def update_user_variable_in_db(user_id: int, variable_name: str, variable_value: str):\n    \"\"\"Сохраняет переменную пользователя в базу данных\"\"\"\n    if not db_pool:\n        return False\n    try:\n        import json\n        async with db_pool.acquire() as conn:\n            # Сначала создаём или получаем существующую запись\n            await conn.execute(\"\"\"\n                INSERT INTO bot_users (user_id) \n                VALUES ($1) \n                ON CONFLICT (user_id) DO NOTHING\n            \"\"\", user_id)\n            \n            # Обновляем переменную пользователя\n            update_data = {variable_name: variable_value}\n            await conn.execute(\"\"\"\n                UPDATE bot_users \n                SET user_data = COALESCE(user_data, '{}'::jsonb) || $2::jsonb,\n                    last_interaction = NOW()\n                WHERE user_id = $1\n            \"\"\", user_id, json.dumps(update_data))\n        return True\n    except Exception as e:\n        logging.error(f\"Ошибка сохранения переменной пользователя: {e}\")\n        return False\n\n\n# Утилитарные функции\nasync def is_admin(user_id: int) -> bool:\n    return user_id in ADMIN_IDS\n\nasync def is_private_chat(message: types.Message) -> bool:\n    return message.chat.type == \"private\"\n\nasync def check_auth(user_id: int) -> bool:\n    # Проверяем наличие пользователя в БД или локальном хранилище\n    if db_pool:\n        user = await get_user_from_db(user_id)\n        return user is not None\n    return user_id in user_data\n\ndef is_local_file(url: str) -> bool:\n    \"\"\"Проверяет, является ли URL локальным загруженным файлом\"\"\"\n    return url.startswith(\"/uploads/\") or url.startswith(\"uploads/\")\n\ndef get_local_file_path(url: str) -> str:\n    \"\"\"Получает локальный путь к файлу из URL\"\"\"\n    if url.startswith(\"/\"):\n        return url[1:]  # Убираем ведущий слеш\n    return url\n\ndef extract_coordinates_from_yandex(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Яндекс.Карт\"\"\"\n    import re\n    # Ищем координаты в формате ll=longitude,latitude\n    match = re.search(r\"ll=([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Ищем координаты в формате /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_google(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки Google Maps\"\"\"\n    import re\n    # Ищем координаты в формате @latitude,longitude\n    match = re.search(r\"@([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    # Ищем координаты в формате /latitude,longitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(1)), float(match.group(2))  # lat, lon\n    return None, None\n\ndef extract_coordinates_from_2gis(url: str) -> tuple:\n    \"\"\"Извлекает координаты из ссылки 2ГИС\"\"\"\n    import re\n    # Ищем координаты в различных форматах 2ГИС\n    # Формат: center/longitude,latitude\n    match = re.search(r\"center/([\\d.-]+),([\\d.-]+)\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    # Формат: /longitude,latitude/\n    match = re.search(r\"/([\\d.-]+),([\\d.-]+)/\", url)\n    if match:\n        return float(match.group(2)), float(match.group(1))  # lat, lon\n    return None, None\n\ndef generate_map_urls(latitude: float, longitude: float, title: str = \"\") -> dict:\n    \"\"\"Генерирует ссылки на различные картографические сервисы\"\"\"\n    import urllib.parse\n    \n    encoded_title = urllib.parse.quote(title) if title else \"\"\n    \n    return {\n        \"yandex\": f\"https://yandex.ru/maps/?ll={longitude},{latitude}&z=15&l=map&pt={longitude},{latitude}\",\n        \"google\": f\"https://maps.google.com/?q={latitude},{longitude}\",\n        \"2gis\": f\"https://2gis.ru/geo/{longitude},{latitude}\",\n        \"openstreetmap\": f\"https://www.openstreetmap.org/?mlat={latitude}&mlon={longitude}&zoom=15\"\n    }\n\n\n@dp.message(CommandStart())\nasync def start_handler(message: types.Message):\n\n    # Регистрируем пользователя в системе\n    user_id = message.from_user.id\n    username = message.from_user.username\n    first_name = message.from_user.first_name\n    last_name = message.from_user.last_name\n    \n    # Сохраняем пользователя в базу данных\n    saved_to_db = await save_user_to_db(user_id, username, first_name, last_name)\n    \n    # Резервное сохранение в локальное хранилище\n    if not saved_to_db:\n        user_data[user_id] = {\n            \"username\": username,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"registered_at\": message.date\n        }\n        logging.info(f\"Пользователь {user_id} сохранен в локальное хранилище\")\n    else:\n        logging.info(f\"Пользователь {user_id} сохранен в базу данных\")\n\n    # ВАЖНО: ВСЕГДА восстанавливаем состояние множественного выбора из БД\n    # Это критически важно для кнопок \"Изменить выбор\" и \"Начать заново\"\n    user_record = await get_user_from_db(user_id)\n    saved_interests = []\n    \n    if user_record and isinstance(user_record, dict):\n        user_data_field = user_record.get(\"user_data\", {})\n        if isinstance(user_data_field, str):\n            import json\n            try:\n                user_vars = json.loads(user_data_field)\n            except:\n                user_vars = {}\n        elif isinstance(user_data_field, dict):\n            user_vars = user_data_field\n        else:\n            user_vars = {}\n        \n        # Ищем сохраненные интересы в любой переменной\n        for var_name, var_data in user_vars.items():\n            if \"интерес\" in var_name.lower() or var_name == \"user_interests\":\n                if isinstance(var_data, str) and var_data:\n                    saved_interests = [interest.strip() for interest in var_data.split(\",\")]\n                    logging.info(f\"Восстановлены интересы из переменной {var_name}: {saved_interests}\")\n                    break\n    \n    # ВСЕГДА инициализируем состояние множественного выбора с восстановленными интересами\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"multi_select_start\"] = saved_interests.copy()\n    user_data[user_id][\"multi_select_node\"] = \"start\"\n    logging.info(f\"Инициализировано состояние множественного выбора с {len(saved_interests)} интересами\")\n    \n    # Создаем клавиатуру с восстановленными галочками\n    builder = InlineKeyboardBuilder()\n    \n    # Функция для проверки совпадения интересов\n    def check_interest_match(button_text, saved_list):\n        \"\"\"Проверяет, есть ли интерес в сохраненном списке\"\"\"\n        if not saved_list:\n            return False\n        # Убираем эмодзи и галочки для сравнения\n        clean_button = button_text.replace(\"✅ \", \"\").replace(\"⬜ \", \"\").strip()\n        for saved_interest in saved_list:\n            clean_saved = saved_interest.replace(\"✅ \", \"\").replace(\"⬜ \", \"\").strip()\n            if clean_button == clean_saved or clean_button in clean_saved or clean_saved in clean_button:\n                return True\n        return False\n    \n    sport_selected = check_interest_match(\"⚽ Спорт\", saved_interests)\n    sport_text = \"✅ ⚽ Спорт\" if sport_selected else \"⚽ Спорт\"\n    builder.add(InlineKeyboardButton(text=sport_text, callback_data=\"multi_select_start_sport\"))\n    \n    music_selected = check_interest_match(\"🎵 Музыка\", saved_interests)\n    music_text = \"✅ 🎵 Музыка\" if music_selected else \"🎵 Музыка\"\n    builder.add(InlineKeyboardButton(text=music_text, callback_data=\"multi_select_start_music\"))\n    \n    books_selected = check_interest_match(\"📚 Книги\", saved_interests)\n    books_text = \"✅ 📚 Книги\" if books_selected else \"📚 Книги\"\n    builder.add(InlineKeyboardButton(text=books_text, callback_data=\"multi_select_start_books\"))\n    \n    travel_selected = check_interest_match(\"✈️ Путешествия\", saved_interests)\n    travel_text = \"✅ ✈️ Путешествия\" if travel_selected else \"✈️ Путешествия\"\n    builder.add(InlineKeyboardButton(text=travel_text, callback_data=\"multi_select_start_travel\"))\n    \n    tech_selected = check_interest_match(\"💻 Технологии\", saved_interests)\n    tech_text = \"✅ 💻 Технологии\" if tech_selected else \"💻 Технологии\"\n    builder.add(InlineKeyboardButton(text=tech_text, callback_data=\"multi_select_start_tech\"))\n    \n    cooking_selected = check_interest_match(\"🍳 Кулинария\", saved_interests)\n    cooking_text = \"✅ 🍳 Кулинария\" if cooking_selected else \"🍳 Кулинария\"\n    builder.add(InlineKeyboardButton(text=cooking_text, callback_data=\"multi_select_start_cooking\"))\n    \n    art_selected = check_interest_match(\"🎨 Искусство\", saved_interests)\n    art_text = \"✅ 🎨 Искусство\" if art_selected else \"🎨 Искусство\"\n    builder.add(InlineKeyboardButton(text=art_text, callback_data=\"multi_select_start_art\"))\n    \n    games_selected = check_interest_match(\"🎮 Игры\", saved_interests)\n    games_text = \"✅ 🎮 Игры\" if games_selected else \"🎮 Игры\"\n    builder.add(InlineKeyboardButton(text=games_text, callback_data=\"multi_select_start_games\"))\n    \n    builder.add(InlineKeyboardButton(text=\"Готово\", callback_data=\"multi_select_done_start\"))\n    builder.adjust(2)  # Используем 2 колонки для консистентности\n    keyboard = builder.as_markup()\n    \n    text = \"\"\"👋 Добро пожаловать!\n\nРасскажите нам о ваших интересах. Выберите все, что вам подходит:\"\"\"\n    await message.answer(text, reply_markup=keyboard)\n\n# Обработчики inline кнопок\n\n@dp.callback_query(lambda c: c.data == \"final_message\" or c.data.startswith(\"final_message_btn_\"))\nasync def handle_callback_final_message(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    callback_data = callback_query.data\n    \n    button_text = \"👍 Продолжить\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text  # Простое значение\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Кнопка сохранена: {button_text} (пользователь {user_id})\")\n    \n    # Отправляем сообщение для узла final_message\n    text = \"\"\"✅ Отлично! Ваши предпочтения сохранены.\n\n\nТеперь вы будете получать персонализированные рекомендации на основе ваших интересов.\"\"\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_vars = await get_user_from_db(user_id)\n    if not user_vars:\n        user_vars = user_data.get(user_id, {})\n    \n    # get_user_from_db теперь возвращает уже обработанные user_data\n    if not isinstance(user_vars, dict):\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    \n    # Без условных сообщений - используем обычную клавиатуру\n    keyboard = None\n    # Проверяем, есть ли условная клавиатура\n    if keyboard is None:\n        # ИСПРАВЛЕНИЕ: Используем универсальную функцию создания клавиатуры\n        builder = InlineKeyboardBuilder()\n        logging.info(f\"Создана кнопка команды: 🔄 Начать заново -> cmd_start\")\n        builder.add(InlineKeyboardButton(text=\"🔄 Начать заново\", callback_data=\"cmd_start\"))\n        builder.adjust(1)\n        keyboard = builder.as_markup()\n    # Отправляем сообщение\n    try:\n        if keyboard is not None:\n            await callback_query.message.edit_text(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.edit_text(text)\n    except Exception:\n        if keyboard is not None:\n            await callback_query.message.answer(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.answer(text)\n\n@dp.callback_query(lambda c: c.data == \"cmd_start\")\nasync def handle_callback_cmd_start(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    button_text = \"✏️ Изменить выбор\"\n    \n    # Сохраняем кнопку в базу данных\n    timestamp = get_moscow_time()\n    response_data = button_text\n    await update_user_data_in_db(user_id, button_text, response_data)\n    logging.info(f\"Команда /start выполнена через callback кнопку (пользователь {user_id})\")\n    \n    # Вызываем start_handler правильно через edit_text\n    # Создаем специальный объект для редактирования сообщения\n    class FakeMessageEdit:\n        def __init__(self, callback_query):\n            self.from_user = callback_query.from_user\n            self.chat = callback_query.message.chat\n            self.date = callback_query.message.date\n            self.message_id = callback_query.message.message_id\n            self._callback_query = callback_query\n        \n        async def answer(self, text, parse_mode=None, reply_markup=None):\n            await self._callback_query.message.edit_text(text, parse_mode=parse_mode, reply_markup=reply_markup)\n        \n        async def edit_text(self, text, parse_mode=None, reply_markup=None):\n            await self._callback_query.message.edit_text(text, parse_mode=parse_mode, reply_markup=reply_markup)\n    \n    fake_edit_message = FakeMessageEdit(callback_query)\n    await start_handler(fake_edit_message)\n\n@dp.callback_query(lambda c: c.data == \"interests_result\" or c.data.startswith(\"interests_result_btn_\"))\nasync def handle_callback_interests_result(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    # Handle interests_result node\n    user_id = callback_query.from_user.id\n    text = \"\"\"🎯 Ваши интересы:\n\n{user_interests}\n\nваши метро: \n\nСпасибо за информацию! Теперь мы сможем предложить вам более подходящий контент.\"\"\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_vars = await get_user_from_db(user_id)\n    if not user_vars:\n        user_vars = user_data.get(user_id, {})\n    \n    # get_user_from_db теперь возвращает уже обработанные user_data\n    if not isinstance(user_vars, dict):\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # ИСПРАВЛЕНИЕ: Проверяем, нужно ли показать метро клавиатуру\n    show_metro_keyboard = user_data.get(user_id, {}).get(\"show_metro_keyboard\", False)\n    saved_metro = user_data.get(user_id, {}).get(\"saved_metro_selection\", [])\n    logging.info(f\"🚇 interests_result: show_metro_keyboard={show_metro_keyboard}, saved_metro={saved_metro}\")\n    \n    # Создаем метро клавиатуру если нужно\n    if show_metro_keyboard:\n        logging.info(\"🚇 Показываем метро клавиатуру в interests_result\")\n        builder = InlineKeyboardBuilder()\n        # Кнопка метро: Красная ветка 🟥\n        selected_metro = \"Красная ветка 🟥\" in saved_metro\n        button_text = \"✅ \" + \"Красная ветка 🟥\" if selected_metro else \"Красная ветка 🟥\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_red_line\"))\n        # Кнопка метро: Синяя ветка 🟦\n        selected_metro = \"Синяя ветка 🟦\" in saved_metro\n        button_text = \"✅ \" + \"Синяя ветка 🟦\" if selected_metro else \"Синяя ветка 🟦\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_blue_line\"))\n        # Кнопка метро: Зелёная ветка 🟩\n        selected_metro = \"Зелёная ветка 🟩\" in saved_metro\n        button_text = \"✅ \" + \"Зелёная ветка 🟩\" if selected_metro else \"Зелёная ветка 🟩\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_green_line\"))\n        # Кнопка метро: Оранжевая ветка 🟧\n        selected_metro = \"Оранжевая ветка 🟧\" in saved_metro\n        button_text = \"✅ \" + \"Оранжевая ветка 🟧\" if selected_metro else \"Оранжевая ветка 🟧\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_orange_line\"))\n        # Кнопка метро: Фиолетовая ветка 🟪\n        selected_metro = \"Фиолетовая ветка 🟪\" in saved_metro\n        button_text = \"✅ \" + \"Фиолетовая ветка 🟪\" if selected_metro else \"Фиолетовая ветка 🟪\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_purple_line\"))\n        # Кнопка метро: Я из ЛО 🏡\n        selected_metro = \"Я из ЛО 🏡\" in saved_metro\n        button_text = \"✅ \" + \"Я из ЛО 🏡\" if selected_metro else \"Я из ЛО 🏡\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_lo_cities\"))\n        # Кнопка метро: Я не в Питере 🌍\n        selected_metro = \"Я не в Питере 🌍\" in saved_metro\n        button_text = \"✅ \" + \"Я не в Питере 🌍\" if selected_metro else \"Я не в Питере 🌍\"\n        builder.add(InlineKeyboardButton(text=button_text, callback_data=\"ms_a12dc5bu6_not_in_spb\"))\n        builder.add(InlineKeyboardButton(text=\"✅ Готово\", callback_data=\"done_a12dc5bu6\"))\n        builder.adjust(2)  # 2 кнопки в ряд\n        metro_keyboard = builder.as_markup()\n        \n        # Добавляем обычные кнопки interests_result\n        result_builder = InlineKeyboardBuilder()\n        result_builder.add(InlineKeyboardButton(text=\"👍 Продолжить\", callback_data=\"final_message_btn_0\"))\n        result_builder.add(InlineKeyboardButton(text=\"✏️ Изменить выбор\", callback_data=\"cmd_start\"))\n        result_keyboard = result_builder.as_markup()\n        \n        # Объединяем клавиатуры\n        combined_keyboard = InlineKeyboardMarkup(inline_keyboard=metro_keyboard.inline_keyboard + result_keyboard.inline_keyboard)\n        await bot.send_message(user_id, text, reply_markup=combined_keyboard)\n    else:\n        # Обычная логика без метро клавиатуры\n        builder = InlineKeyboardBuilder()\n        builder.add(InlineKeyboardButton(text=\"👍 Продолжить\", callback_data=\"final_message_btn_0\"))\n        builder.add(InlineKeyboardButton(text=\"✏️ Изменить выбор\", callback_data=\"cmd_start\"))\n        keyboard = builder.as_markup()\n        await bot.send_message(user_id, text, reply_markup=keyboard)\n\n\n@dp.callback_query(lambda c: c.data == \"metro_selection_paste_1754804051442_a12dc5bu6\" or c.data.startswith(\"metro_selection_paste_1754804051442_a12dc5bu6_btn_\") or c.data == \"done_a12dc5bu6\")\nasync def handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    callback_data = callback_query.data\n    \n    # Проверяем, является ли это кнопкой \"Готово\"\n    if callback_data == \"done_a12dc5bu6\":\n        logging.info(f\"🏁 Обработка кнопки Готово для множественного выбора: {callback_data}\")\n        \n        # Сохраняем выбранные значения в базу данных\n        selected_options = user_data.get(user_id, {}).get(\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\", [])\n        if selected_options:\n            selected_text = \", \".join(selected_options)\n            await update_user_data_in_db(user_id, \"metro_lines\", selected_text)\n            logging.info(f\"✅ Сохранено в переменную metro_lines: {selected_text}\")\n        \n        # Очищаем состояние множественного выбора\n        if user_id in user_data:\n            user_data[user_id].pop(\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\", None)\n            user_data[user_id].pop(\"multi_select_node\", None)\n            user_data[user_id].pop(\"multi_select_type\", None)\n            user_data[user_id].pop(\"multi_select_variable\", None)\n        \n        # Переход к следующему узлу\n        next_node_id = \"interests_result\"\n        try:\n            await handle_callback_interests_result(callback_query)\n        except Exception as e:\n            logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            await callback_query.message.edit_text(\"Переход завершен\")\n        return\n    \n    # Обрабатываем узел metro_selection_paste_1754804051442_a12dc5bu6: metro_selection_paste_1754804051442_a12dc5bu6\n    text = \"\"\"На какой станции метро ты обычно бываешь? 🚇\n\nМожешь выбрать несколько веток:\"\"\"\n    \n    # Подставляем все доступные переменные пользователя в текст\n    user_vars = await get_user_from_db(user_id)\n    if not user_vars:\n        user_vars = user_data.get(user_id, {})\n    \n    # get_user_from_db теперь возвращает уже обработанные user_data\n    if not isinstance(user_vars, dict):\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    # Инициализация состояния множественного выбора\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    \n    # Загружаем ранее выбранные варианты\n    saved_selections = []\n    if user_vars:\n        for var_name, var_data in user_vars.items():\n            if var_name == \"metro_lines\":\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    selections_str = var_data[\"value\"]\n                elif isinstance(var_data, str):\n                    selections_str = var_data\n                else:\n                    continue\n                if selections_str and selections_str.strip():\n                    saved_selections = [sel.strip() for sel in selections_str.split(\",\") if sel.strip()]\n                    break\n    \n    # Инициализируем состояние если его нет\n    if \"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\" not in user_data[user_id]:\n        user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] = saved_selections.copy()\n    user_data[user_id][\"multi_select_node\"] = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n    user_data[user_id][\"multi_select_type\"] = \"inline\"\n    user_data[user_id][\"multi_select_variable\"] = \"metro_lines\"\n    logging.info(f\"Инициализировано состояние множественного выбора с {len(saved_selections)} элементами\")\n    \n    # Создаем inline клавиатуру с поддержкой множественного выбора\n    builder = InlineKeyboardBuilder()\n    # Кнопка выбора 1: Красная ветка 🟥\n    logging.info(f\"🔘 Создаем кнопку: Красная ветка 🟥 -> ms_a12dc5bu6_red_line\")\n    selected_mark = \"✅ \" if \"Красная ветка 🟥\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Красная ветка 🟥\", callback_data=\"ms_a12dc5bu6_red_line\"))\n    # Кнопка выбора 2: Синяя ветка 🟦\n    logging.info(f\"🔘 Создаем кнопку: Синяя ветка 🟦 -> ms_a12dc5bu6_lue_line\")\n    selected_mark = \"✅ \" if \"Синяя ветка 🟦\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Синяя ветка 🟦\", callback_data=\"ms_a12dc5bu6_lue_line\"))\n    # Кнопка выбора 3: Зелёная ветка 🟩\n    logging.info(f\"🔘 Создаем кнопку: Зелёная ветка 🟩 -> ms_a12dc5bu6_een_line\")\n    selected_mark = \"✅ \" if \"Зелёная ветка 🟩\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Зелёная ветка 🟩\", callback_data=\"ms_a12dc5bu6_een_line\"))\n    # Кнопка выбора 4: Оранжевая ветка 🟧\n    logging.info(f\"🔘 Создаем кнопку: Оранжевая ветка 🟧 -> ms_a12dc5bu6_nge_line\")\n    selected_mark = \"✅ \" if \"Оранжевая ветка 🟧\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Оранжевая ветка 🟧\", callback_data=\"ms_a12dc5bu6_nge_line\"))\n    # Кнопка выбора 5: Фиолетовая ветка 🟪\n    logging.info(f\"🔘 Создаем кнопку: Фиолетовая ветка 🟪 -> ms_a12dc5bu6_ple_line\")\n    selected_mark = \"✅ \" if \"Фиолетовая ветка 🟪\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Фиолетовая ветка 🟪\", callback_data=\"ms_a12dc5bu6_ple_line\"))\n    # Кнопка выбора 6: Я из ЛО 🏡\n    logging.info(f\"🔘 Создаем кнопку: Я из ЛО 🏡 -> ms_a12dc5bu6_o_cities\")\n    selected_mark = \"✅ \" if \"Я из ЛО 🏡\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Я из ЛО 🏡\", callback_data=\"ms_a12dc5bu6_o_cities\"))\n    # Кнопка выбора 7: Я не в Питере 🌍\n    logging.info(f\"🔘 Создаем кнопку: Я не в Питере 🌍 -> ms_a12dc5bu6_t_in_spb\")\n    selected_mark = \"✅ \" if \"Я не в Питере 🌍\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n    builder.add(InlineKeyboardButton(text=f\"{selected_mark}Я не в Питере 🌍\", callback_data=\"ms_a12dc5bu6_t_in_spb\"))\n    # Кнопка \"Готово\" для множественного выбора\n    logging.info(f\"🔘 Создаем кнопку Готово -> done_a12dc5bu6\")\n    builder.add(InlineKeyboardButton(text=\"Готово\", callback_data=\"done_a12dc5bu6\"))\n    builder.adjust(2)\n    keyboard = builder.as_markup()\n    # Отправляем сообщение\n    try:\n        if keyboard:\n            await callback_query.message.edit_text(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.edit_text(text)\n    except Exception:\n        if keyboard:\n            await callback_query.message.answer(text, reply_markup=keyboard)\n        else:\n            await callback_query.message.answer(text)\n    # Сохраняем нажатие кнопки в базу данных\n    user_id = callback_query.from_user.id\n    \n    # Ищем текст кнопки по callback_data\n    button_display_text = \"Кнопка metro_selection_paste_1754804051442_a12dc5bu6\"\n    \n    # Сохраняем ответ в базу данных\n    timestamp = get_moscow_time()\n    \n    response_data = button_display_text  # Простое значение\n    \n    # Сохраняем в пользовательские данные\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    user_data[user_id][\"button_click\"] = button_display_text\n    \n    # Сохраняем в базу данных с правильным именем переменной\n    await update_user_data_in_db(user_id, \"button_click\", button_display_text)\n    logging.info(f\"Переменная button_click сохранена: \" + str(button_display_text) + f\" (пользователь {user_id})\")\n    \n    # Показываем сообщение об обработке\n    await callback_query.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n    \n    # ПЕРЕАДРЕСАЦИЯ: Переходим к следующему узлу после сохранения данных\n    next_node_id = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n    try:\n        logging.info(f\"🚀 Переходим к следующему узлу после выбора кнопки: {next_node_id}\")\n        if next_node_id == \"start\":\n            logging.info(\"Переход к узлу start\")\n        elif next_node_id == \"interests_result\":\n            nav_text = \"\"\"🎯 Ваши интересы:\n\n{user_interests}\n\nваши метро: \n\nСпасибо за информацию! Теперь мы сможем предложить вам более подходящий контент.\"\"\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"final_message\":\n            nav_text = \"\"\"✅ Отлично! Ваши предпочтения сохранены.\n\n\nТеперь вы будете получать персонализированные рекомендации на основе ваших интересов.\"\"\"\n            await callback_query.message.edit_text(nav_text)\n        elif next_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n            nav_text = \"\"\"На какой станции метро ты обычно бываешь? 🚇\n\nМожешь выбрать несколько веток:\"\"\"\n            await callback_query.message.edit_text(nav_text)\n        else:\n            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n    except Exception as e:\n        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n    \n    return  # Завершаем обработку после переадресации\n    \n    text = \"\"\"На какой станции метро ты обычно бываешь? 🚇\n\nМожешь выбрать несколько веток:\"\"\"\n    # Подставляем все доступные переменные пользователя в текст\n    user_vars = await get_user_from_db(user_id)\n    if not user_vars:\n        user_vars = user_data.get(user_id, {})\n    \n    # get_user_from_db теперь возвращает уже обработанные user_data\n    if not isinstance(user_vars, dict):\n        user_vars = {}\n    \n    # Заменяем все переменные в тексте\n    import re\n    def replace_variables_in_text(text_content, variables_dict):\n        if not text_content or not variables_dict:\n            return text_content\n        \n        for var_name, var_data in variables_dict.items():\n            placeholder = \"{\" + var_name + \"}\"\n            if placeholder in text_content:\n                if isinstance(var_data, dict) and \"value\" in var_data:\n                    var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                elif var_data is not None:\n                    var_value = str(var_data)\n                else:\n                    var_value = var_name  # Показываем имя переменной если значения нет\n                text_content = text_content.replace(placeholder, var_value)\n        return text_content\n    \n    text = replace_variables_in_text(text, user_vars)\n    builder = InlineKeyboardBuilder()\n    keyboard = builder.as_markup()\n    # Пытаемся редактировать сообщение, если не получается - отправляем новое\n    try:\n        await callback_query.message.edit_text(text, reply_markup=keyboard)\n    except Exception as e:\n        logging.warning(f\"Не удалось редактировать сообщение: {e}. Отправляем новое.\")\n        await callback_query.message.answer(text, reply_markup=keyboard)\n\n\n# Универсальный обработчик пользовательского ввода\n@dp.message(F.text)\nasync def handle_user_input(message: types.Message):\n    user_id = message.from_user.id\n    \n    # Проверяем, ожидаем ли мы ввод для условного сообщения\n    if user_id in user_data and \"waiting_for_conditional_input\" in user_data[user_id]:\n        config = user_data[user_id][\"waiting_for_conditional_input\"]\n        user_text = message.text\n        \n        # Сохраняем текстовый ввод для условного сообщения\n        condition_id = config.get(\"condition_id\", \"unknown\")\n        next_node_id = config.get(\"next_node_id\")\n        \n        # Сохраняем ответ пользователя\n        timestamp = get_moscow_time()\n        # Используем переменную из конфигурации или создаем автоматическую\n        input_variable = config.get(\"input_variable\", \"\")\n        if input_variable:\n            variable_name = input_variable\n        else:\n            variable_name = f\"conditional_response_{condition_id}\"\n        \n        # Сохраняем в пользовательские данные\n        user_data[user_id][variable_name] = user_text\n        \n        # Сохраняем в базу данных\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, user_text)\n        if saved_to_db:\n            logging.info(f\"✅ Условный ответ сохранен в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n        \n        # Отправляем подтверждение\n        await message.answer(\"✅ Спасибо за ваш ответ! Обрабатываю...\")\n        \n        # Очищаем состояние ожидания\n        del user_data[user_id][\"waiting_for_conditional_input\"]\n        \n        logging.info(f\"Получен ответ на условное сообщение: {variable_name} = {user_text}\")\n        \n        # Переходим к следующему узлу если указан\n        if next_node_id:\n            try:\n                logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n                \n                # Проверяем, является ли это командой\n                if next_node_id == \"profile_command\":\n                    logging.info(\"Переход к команде /profile\")\n                    await profile_handler(message)\n                else:\n                    # Создаем фиктивный callback для навигации к обычному узлу\n                    import types as aiogram_types\n                    fake_callback = aiogram_types.SimpleNamespace(\n                        id=\"conditional_nav\",\n                        from_user=message.from_user,\n                        chat_instance=\"\",\n                        data=next_node_id,\n                        message=message,\n                        answer=lambda text=\"\", show_alert=False: asyncio.sleep(0)\n                    )\n                    \n                    if next_node_id == \"start\":\n                        await handle_callback_start(fake_callback)\n                    elif next_node_id == \"interests_result\":\n                        await handle_callback_interests_result(fake_callback)\n                    elif next_node_id == \"final_message\":\n                        await handle_callback_final_message(fake_callback)\n                    elif next_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                        await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(fake_callback)\n                    else:\n                        logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n            except Exception as e:\n                logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n        \n        return  # Завершаем обработку для условного сообщения\n    \n    # Проверяем, ожидаем ли мы кнопочный ответ через reply клавиатуру\n    if user_id in user_data and \"button_response_config\" in user_data[user_id]:\n        config = user_data[user_id][\"button_response_config\"]\n        user_text = message.text\n        \n        # Ищем выбранный вариант среди доступных опций\n        selected_option = None\n        for option in config.get(\"options\", []):\n            if option[\"text\"] == user_text:\n                selected_option = option\n                break\n        \n        if selected_option:\n            selected_value = selected_option[\"value\"]\n            selected_text = selected_option[\"text\"]\n            \n            # Сохраняем ответ пользователя\n            variable_name = config.get(\"variable\", \"button_response\")\n            timestamp = get_moscow_time()\n            node_id = config.get(\"node_id\", \"unknown\")\n            \n            # Создаем структурированный ответ\n            response_data = {\n                \"value\": selected_value,\n                \"text\": selected_text,\n                \"type\": \"button_choice\",\n                \"timestamp\": timestamp,\n                \"nodeId\": node_id,\n                \"variable\": variable_name\n            }\n            \n            # Сохраняем в пользовательские данные\n            user_data[user_id][variable_name] = response_data\n            \n            # Сохраняем в базу данных если включено\n            if config.get(\"save_to_database\"):\n                saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                if saved_to_db:\n                    logging.info(f\"✅ Кнопочный ответ сохранен в БД: {variable_name} = {selected_text} (пользователь {user_id})\")\n                else:\n                    logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n            \n            # Отправляем сообщение об успехе\n            success_message = config.get(\"success_message\", \"Спасибо за ваш выбор!\")\n            await message.answer(f\"{success_message}\\n\\n✅ Ваш выбор: {selected_text}\", reply_markup=ReplyKeyboardRemove())\n            \n            # Очищаем состояние\n            del user_data[user_id][\"button_response_config\"]\n            \n            logging.info(f\"Получен кнопочный ответ через reply клавиатуру: {variable_name} = {selected_text}\")\n            \n            # Навигация на основе действия кнопки\n            option_action = selected_option.get(\"action\", \"goto\")\n            option_target = selected_option.get(\"target\", \"\")\n            option_url = selected_option.get(\"url\", \"\")\n            \n            if option_action == \"url\" and option_url:\n                # Открытие ссылки\n                url = option_url\n                keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"🔗 Открыть ссылку\", url=url)]\n                ])\n                await message.answer(\"Нажмите кнопку ниже, чтобы открыть ссылку:\", reply_markup=keyboard)\n            elif option_action == \"command\" and option_target:\n                # Выполнение команды\n                command = option_target\n                # Создаем фиктивное сообщение для выполнения команды\n                import types as aiogram_types\n                fake_message = aiogram_types.SimpleNamespace(\n                    from_user=message.from_user,\n                    chat=message.chat,\n                    text=command,\n                    message_id=message.message_id\n                )\n                \n                if command == \"/start\":\n                    try:\n                        await start_handler(fake_message)\n                    except Exception as e:\n                        logging.error(f\"Ошибка выполнения команды /start: {e}\")\n                else:\n                    logging.warning(f\"Неизвестная команда: {command}\")\n            elif option_action == \"goto\" and option_target:\n                # Переход к узлу\n                target_node_id = option_target\n                try:\n                    # Вызываем обработчик для целевого узла\n                    if target_node_id == \"start\":\n                        await handle_callback_start(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"interests_result\":\n                        await handle_callback_interests_result(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"final_message\":\n                        await handle_callback_final_message(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    elif target_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                        await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=target_node_id, message=message))\n                    else:\n                        logging.warning(f\"Неизвестный целевой узел: {target_node_id}\")\n                except Exception as e:\n                    logging.error(f\"Ошибка при переходе к узлу {target_node_id}: {e}\")\n            else:\n                # Fallback к старой системе next_node_id если нет action\n                next_node_id = config.get(\"next_node_id\")\n                if next_node_id:\n                    try:\n                        # Вызываем обработчик для следующего узла\n                        if next_node_id == \"start\":\n                            await handle_callback_start(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"interests_result\":\n                            await handle_callback_interests_result(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"final_message\":\n                            await handle_callback_final_message(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        elif next_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                            await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(types.CallbackQuery(id=\"reply_nav\", from_user=message.from_user, chat_instance=\"\", data=next_node_id, message=message))\n                        else:\n                            logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                    except Exception as e:\n                        logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            return\n        else:\n            # Неверный выбор - показываем доступные варианты\n            available_options = [option[\"text\"] for option in config.get(\"options\", [])]\n            options_text = \"\\n\".join([f\"• {opt}\" for opt in available_options])\n            await message.answer(f\"❌ Неверный выбор. Пожалуйста, выберите один из предложенных вариантов:\\n\\n{options_text}\")\n            return\n    \n    # Проверяем, ожидаем ли мы текстовый ввод от пользователя (универсальная система)\n    has_waiting_state = user_id in user_data and \"waiting_for_input\" in user_data[user_id]\n    logging.info(f\"DEBUG: Получен текст {message.text}, состояние ожидания: {has_waiting_state}\")\n    if user_id in user_data and \"waiting_for_input\" in user_data[user_id]:\n        # Обрабатываем ввод через универсальную систему\n        waiting_config = user_data[user_id][\"waiting_for_input\"]\n        \n        # ИСПРАВЛЕНИЕ: Проверяем, что пользователь все еще находится в состоянии ожидания ввода\n        # и что ввод предназначен для правильного узла\n        if not waiting_config:\n            return  # Состояние ожидания пустое, игнорируем\n        \n        # Проверяем, был ли уже обработан ввод для данного узла\n        current_node_id = waiting_config.get(\"node_id\") if isinstance(waiting_config, dict) else waiting_config\n        processed_inputs = user_data[user_id].get(\"processed_inputs\", set())\n        if current_node_id in processed_inputs:\n            logging.info(f\"Ввод для узла {current_node_id} уже был обработан, игнорируем\")\n            return  # Ввод для этого узла уже был обработан\n        \n        # ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА: если переменная уже сохранена inline кнопкой, не перезаписываем\n        variable_name_preview = waiting_config.get(\"variable\") if isinstance(waiting_config, dict) else user_data[user_id].get(\"input_variable\", \"user_response\")\n        if variable_name_preview in user_data[user_id] and user_data[user_id][variable_name_preview]:\n            logging.info(f\"Переменная {variable_name_preview} уже сохранена, игнорируем текстовый ввод\")\n            # Очищаем состояние ожидания и переходим дальше\n            del user_data[user_id][\"waiting_for_input\"]\n            return\n        \n        # Проверяем формат конфигурации - новый (словарь) или старый (строка)\n        if isinstance(waiting_config, dict):\n            # Новый формат - извлекаем данные из словаря\n            waiting_node_id = waiting_config.get(\"node_id\")\n            input_type = waiting_config.get(\"type\", \"text\")\n            variable_name = waiting_config.get(\"variable\", \"user_response\")\n            save_to_database = waiting_config.get(\"save_to_database\", False)\n            min_length = waiting_config.get(\"min_length\", 0)\n            max_length = waiting_config.get(\"max_length\", 0)\n            next_node_id = waiting_config.get(\"next_node_id\")\n        else:\n            # Старый формат - waiting_config это строка с node_id\n            waiting_node_id = waiting_config\n            input_type = user_data[user_id].get(\"input_type\", \"text\")\n            variable_name = user_data[user_id].get(\"input_variable\", \"user_response\")\n            save_to_database = user_data[user_id].get(\"save_to_database\", False)\n            min_length = 0\n            max_length = 0\n            next_node_id = user_data[user_id].get(\"input_target_node_id\")\n        \n        user_text = message.text\n        \n        # Валидация для нового формата\n        if isinstance(waiting_config, dict):\n            # Валидация длины\n            if min_length > 0 and len(user_text) < min_length:\n                retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                await message.answer(f\"❌ Слишком короткий ответ (минимум {min_length} символов). {retry_message}\")\n                return\n            \n            if max_length > 0 and len(user_text) > max_length:\n                retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                await message.answer(f\"❌ Слишком длинный ответ (максимум {max_length} символов). {retry_message}\")\n                return\n            \n            # Валидация типа ввода\n            if input_type == \"email\":\n                import re\n                email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n                if not re.match(email_pattern, user_text):\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Неверный формат email. {retry_message}\")\n                    return\n            elif input_type == \"number\":\n                try:\n                    float(user_text)\n                except ValueError:\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Введите корректное число. {retry_message}\")\n                    return\n            elif input_type == \"phone\":\n                import re\n                phone_pattern = r\"^[+]?[0-9\\s\\-\\(\\)]{10,}$\"\n                if not re.match(phone_pattern, user_text):\n                    retry_message = waiting_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n                    await message.answer(f\"❌ Неверный формат телефона. {retry_message}\")\n                    return\n            \n            # Сохраняем ответ для нового формата\n            timestamp = get_moscow_time()\n            response_data = user_text\n            \n            # Сохраняем в пользовательские данные\n            user_data[user_id][variable_name] = response_data\n            \n            # Сохраняем в базу данных если включено\n            if save_to_database:\n                saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n                if saved_to_db:\n                    logging.info(f\"✅ Данные сохранены в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n                else:\n                    logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n            \n            # ИСПРАВЛЕНО: Отправляем подтверждающее сообщение\n            success_message = waiting_config.get(\"success_message\", \"✅ Спасибо за ваш ответ!\")\n            logging.info(f\"DEBUG: Отправляем подтверждение с текстом: {success_message}\")\n            await message.answer(success_message)\n            logging.info(f\"✅ Отправлено подтверждение: {success_message}\")\n            \n            # ИСПРАВЛЕНИЕ: Добавляем маркер, что ввод был обработан для этого узла\n            if \"processed_inputs\" not in user_data[user_id]:\n                user_data[user_id][\"processed_inputs\"] = set()\n            user_data[user_id][\"processed_inputs\"].add(waiting_node_id)\n            \n            logging.info(f\"✅ Переход к следующему узлу выполнен успешно\")\n            logging.info(f\"Получен пользовательский ввод: {variable_name} = {user_text}\")\n            \n            # Навигация к следующему узлу для нового формата\n            if next_node_id:\n                try:\n                    logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n                    # Проверяем навигацию к узлам\n                    if next_node_id == \"start\":\n                        logging.info(f\"Переход к узлу start типа start\")\n                    elif next_node_id == \"interests_result\":\n                        text = \"\"\"🎯 Ваши интересы:\n\n{user_interests}\n\nваши метро: \n\nСпасибо за информацию! Теперь мы сможем предложить вам более подходящий контент.\"\"\"\n                        # Замена переменных в тексте\n                        # Подставляем все доступные переменные пользователя в текст\n                        user_vars = await get_user_from_db(user_id)\n                        if not user_vars:\n                            user_vars = user_data.get(user_id, {})\n                        \n                        # get_user_from_db теперь возвращает уже обработанные user_data\n                        if not isinstance(user_vars, dict):\n                            user_vars = {}\n                        \n                        # Заменяем все переменные в тексте\n                        import re\n                        def replace_variables_in_text(text_content, variables_dict):\n                            if not text_content or not variables_dict:\n                                return text_content\n                            \n                            for var_name, var_data in variables_dict.items():\n                                placeholder = \"{\" + var_name + \"}\"\n                                if placeholder in text_content:\n                                    if isinstance(var_data, dict) and \"value\" in var_data:\n                                        var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                                    elif var_data is not None:\n                                        var_value = str(var_data)\n                                    else:\n                                        var_value = var_name  # Показываем имя переменной если значения нет\n                                    text_content = text_content.replace(placeholder, var_value)\n                            return text_content\n                        \n                        text = replace_variables_in_text(text, user_vars)\n                        # Создаем inline клавиатуру\n                        builder = InlineKeyboardBuilder()\n                        builder.add(InlineKeyboardButton(text=\"👍 Продолжить\", callback_data=\"final_message\"))\n                        logging.info(f\"Создана кнопка команды: ✏️ Изменить выбор -> cmd_start\")\n                        builder.add(InlineKeyboardButton(text=\"✏️ Изменить выбор\", callback_data=\"cmd_start\"))\n                        builder.adjust(1)\n                        keyboard = builder.as_markup()\n                        await message.answer(text, reply_markup=keyboard)\n                        # НЕ отправляем сообщение об успехе здесь - это делается в старом формате\n                        # Очищаем состояние ожидания ввода после успешного перехода\n                        if \"waiting_for_input\" in user_data[user_id]:\n                            del user_data[user_id][\"waiting_for_input\"]\n                        \n                        logging.info(\"✅ Переход к следующему узлу выполнен успешно\")\n                    elif next_node_id == \"final_message\":\n                        text = \"\"\"✅ Отлично! Ваши предпочтения сохранены.\n\n\nТеперь вы будете получать персонализированные рекомендации на основе ваших интересов.\"\"\"\n                        # Замена переменных в тексте\n                        # Подставляем все доступные переменные пользователя в текст\n                        user_vars = await get_user_from_db(user_id)\n                        if not user_vars:\n                            user_vars = user_data.get(user_id, {})\n                        \n                        # get_user_from_db теперь возвращает уже обработанные user_data\n                        if not isinstance(user_vars, dict):\n                            user_vars = {}\n                        \n                        # Заменяем все переменные в тексте\n                        import re\n                        def replace_variables_in_text(text_content, variables_dict):\n                            if not text_content or not variables_dict:\n                                return text_content\n                            \n                            for var_name, var_data in variables_dict.items():\n                                placeholder = \"{\" + var_name + \"}\"\n                                if placeholder in text_content:\n                                    if isinstance(var_data, dict) and \"value\" in var_data:\n                                        var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                                    elif var_data is not None:\n                                        var_value = str(var_data)\n                                    else:\n                                        var_value = var_name  # Показываем имя переменной если значения нет\n                                    text_content = text_content.replace(placeholder, var_value)\n                            return text_content\n                        \n                        text = replace_variables_in_text(text, user_vars)\n                        # Создаем inline клавиатуру\n                        builder = InlineKeyboardBuilder()\n                        logging.info(f\"Создана кнопка команды: 🔄 Начать заново -> cmd_start\")\n                        builder.add(InlineKeyboardButton(text=\"🔄 Начать заново\", callback_data=\"cmd_start\"))\n                        builder.adjust(1)\n                        keyboard = builder.as_markup()\n                        await message.answer(text, reply_markup=keyboard)\n                        # НЕ отправляем сообщение об успехе здесь - это делается в старом формате\n                        # Очищаем состояние ожидания ввода после успешного перехода\n                        if \"waiting_for_input\" in user_data[user_id]:\n                            del user_data[user_id][\"waiting_for_input\"]\n                        \n                        logging.info(\"✅ Переход к следующему узлу выполнен успешно\")\n                    elif next_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                        text = \"\"\"На какой станции метро ты обычно бываешь? 🚇\n\nМожешь выбрать несколько веток:\"\"\"\n                        # Замена переменных в тексте\n                        # Подставляем все доступные переменные пользователя в текст\n                        user_vars = await get_user_from_db(user_id)\n                        if not user_vars:\n                            user_vars = user_data.get(user_id, {})\n                        \n                        # get_user_from_db теперь возвращает уже обработанные user_data\n                        if not isinstance(user_vars, dict):\n                            user_vars = {}\n                        \n                        # Заменяем все переменные в тексте\n                        import re\n                        def replace_variables_in_text(text_content, variables_dict):\n                            if not text_content or not variables_dict:\n                                return text_content\n                            \n                            for var_name, var_data in variables_dict.items():\n                                placeholder = \"{\" + var_name + \"}\"\n                                if placeholder in text_content:\n                                    if isinstance(var_data, dict) and \"value\" in var_data:\n                                        var_value = str(var_data[\"value\"]) if var_data[\"value\"] is not None else var_name\n                                    elif var_data is not None:\n                                        var_value = str(var_data)\n                                    else:\n                                        var_value = var_name  # Показываем имя переменной если значения нет\n                                    text_content = text_content.replace(placeholder, var_value)\n                            return text_content\n                        \n                        text = replace_variables_in_text(text, user_vars)\n                        # Создаем inline клавиатуру\n                        builder = InlineKeyboardBuilder()\n                        builder.adjust(2)\n                        keyboard = builder.as_markup()\n                        await message.answer(text, reply_markup=keyboard)\n                        # НЕ отправляем сообщение об успехе здесь - это делается в старом формате\n                        # Очищаем состояние ожидания ввода после успешного перехода\n                        if \"waiting_for_input\" in user_data[user_id]:\n                            del user_data[user_id][\"waiting_for_input\"]\n                        \n                        logging.info(\"✅ Переход к следующему узлу выполнен успешно\")\n                    else:\n                        logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n                except Exception as e:\n                    logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n            \n            return  # Завершаем обработку для нового формата\n        \n        # Обработка старого формата (для совместимости)\n        # Находим узел для получения настроек\n        logging.info(f\"DEBUG old format: checking inputNodes: \")\n        \n        # Если узел не найден\n        logging.warning(f\"Узел для сбора ввода не найден: {waiting_node_id}\")\n        del user_data[user_id][\"waiting_for_input\"]\n        return\n    \n    # НОВАЯ ЛОГИКА: Проверяем, включен ли дополнительный сбор ответов для обычных кнопок\n    if user_id in user_data and user_data[user_id].get(\"input_collection_enabled\"):\n        input_node_id = user_data[user_id].get(\"input_node_id\")\n        input_variable = user_data[user_id].get(\"input_variable\", \"button_response\")\n        user_text = message.text\n        \n        # Сохраняем любой текст как дополнительный ответ\n        timestamp = get_moscow_time()\n        \n        response_data = user_text  # Простое значение\n        \n        # Сохраняем в пользовательские данные\n        user_data[user_id][f\"{input_variable}_additional\"] = response_data\n        \n        # Уведомляем пользователя\n        await message.answer(\"✅ Дополнительный комментарий сохранен!\")\n        \n        logging.info(f\"Дополнительный текстовый ввод: {input_variable}_additional = {user_text} (пользователь {user_id})\")\n        return\n    \n    # Если нет активного ожидания ввода, игнорируем сообщение\n    return\n    # Валидация длины текста\n    min_length = input_config.get(\"min_length\", 0)\n    max_length = input_config.get(\"max_length\", 0)\n    \n    if min_length > 0 and len(user_text) < min_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком короткий ответ (минимум {min_length} символов). {retry_message}\")\n        return\n    \n    if max_length > 0 and len(user_text) > max_length:\n        retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n        await message.answer(f\"❌ Слишком длинный ответ (максимум {max_length} символов). {retry_message}\")\n        return\n    \n    # Валидация типа ввода\n    input_type = input_config.get(\"type\", \"text\")\n    \n    if input_type == \"email\":\n        import re\n        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        if not re.match(email_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат email. {retry_message}\")\n            return\n    \n    elif input_type == \"number\":\n        try:\n            float(user_text)\n        except ValueError:\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Введите корректное число. {retry_message}\")\n            return\n    \n    elif input_type == \"phone\":\n        import re\n        phone_pattern = r\"^[+]?[0-9\\s\\-\\(\\)]{10,}$\"\n        if not re.match(phone_pattern, user_text):\n            retry_message = input_config.get(\"retry_message\", \"Пожалуйста, попробуйте еще раз.\")\n            await message.answer(f\"❌ Неверный формат телефона. {retry_message}\")\n            return\n    \n    # Сохраняем ответ пользователя простым значением\n    variable_name = input_config.get(\"variable\", \"user_response\")\n    timestamp = get_moscow_time()\n    node_id = input_config.get(\"node_id\", \"unknown\")\n    \n    # Простое значение вместо сложного объекта\n    response_data = user_text\n    \n    # Сохраняем в пользовательские данные\n    user_data[user_id][variable_name] = response_data\n    \n    # Сохраняем в базу данных если включено\n    if input_config.get(\"save_to_database\"):\n        saved_to_db = await update_user_data_in_db(user_id, variable_name, response_data)\n        if saved_to_db:\n            logging.info(f\"✅ Данные сохранены в БД: {variable_name} = {user_text} (пользователь {user_id})\")\n        else:\n            logging.warning(f\"⚠️ Не удалось сохранить в БД, данные сохранены локально\")\n    \n    # Отправляем сообщение об успехе\n    success_message = input_config.get(\"success_message\", \"✅ Спасибо за ваш ответ!\")\n    await message.answer(success_message)\n    \n    # Очищаем состояние ожидания ввода\n    del user_data[user_id][\"waiting_for_input\"]\n    \n    logging.info(f\"Получен пользовательский ввод: {variable_name} = {user_text}\")\n    \n    # Автоматическая навигация к следующему узлу после успешного ввода\n    next_node_id = input_config.get(\"next_node_id\")\n    logging.info(f\"🔄 Проверяем навигацию: next_node_id = {next_node_id}\")\n    if next_node_id:\n        try:\n            logging.info(f\"🚀 Переходим к следующему узлу: {next_node_id}\")\n            \n            # Создаем фейковое сообщение для навигации\n            fake_message = type(\"FakeMessage\", (), {})()\n            fake_message.from_user = message.from_user\n            fake_message.answer = message.answer\n            fake_message.delete = lambda: None\n            \n            # Находим узел по ID и выполняем соответствующее действие\n            if next_node_id == \"start\":\n                logging.info(f\"Переход к узлу start типа start\")\n            elif next_node_id == \"interests_result\":\n                text = \"\"\"🎯 Ваши интересы:\n\n{user_interests}\n\nваши метро: \n\nСпасибо за информацию! Теперь мы сможем предложить вам более подходящий контент.\"\"\"\n                # Используем parse_mode условного сообщения если он установлен\n                if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n                    parse_mode = conditional_parse_mode\n                else:\n                    parse_mode = None\n                builder = InlineKeyboardBuilder()\n                builder.add(InlineKeyboardButton(text=\"👍 Продолжить\", callback_data=\"final_message\"))\n                logging.info(f\"Создана кнопка команды: ✏️ Изменить выбор -> cmd_start\")\n                builder.add(InlineKeyboardButton(text=\"✏️ Изменить выбор\", callback_data=\"cmd_start\"))\n                builder.adjust(1)\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            elif next_node_id == \"final_message\":\n                text = \"\"\"✅ Отлично! Ваши предпочтения сохранены.\n\n\nТеперь вы будете получать персонализированные рекомендации на основе ваших интересов.\"\"\"\n                # Используем parse_mode условного сообщения если он установлен\n                if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n                    parse_mode = conditional_parse_mode\n                else:\n                    parse_mode = None\n                builder = InlineKeyboardBuilder()\n                logging.info(f\"Создана кнопка команды: 🔄 Начать заново -> cmd_start\")\n                builder.add(InlineKeyboardButton(text=\"🔄 Начать заново\", callback_data=\"cmd_start\"))\n                builder.adjust(1)\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            elif next_node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                text = \"\"\"На какой станции метро ты обычно бываешь? 🚇\n\nМожешь выбрать несколько веток:\"\"\"\n                # Используем parse_mode условного сообщения если он установлен\n                if \"conditional_parse_mode\" in locals() and conditional_parse_mode is not None:\n                    parse_mode = conditional_parse_mode\n                else:\n                    parse_mode = None\n                # Инициализация состояния множественного выбора\n                if user_id not in user_data:\n                    user_data[user_id] = {}\n                \n                # Загружаем ранее выбранные варианты\n                saved_selections = []\n                if user_vars:\n                    for var_name, var_data in user_vars.items():\n                        if var_name == \"metro_lines\":\n                            if isinstance(var_data, dict) and \"value\" in var_data:\n                                selections_str = var_data[\"value\"]\n                            elif isinstance(var_data, str):\n                                selections_str = var_data\n                            else:\n                                continue\n                            if selections_str and selections_str.strip():\n                                saved_selections = [sel.strip() for sel in selections_str.split(\",\") if sel.strip()]\n                                break\n                \n                # Инициализируем состояние если его нет\n                if \"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] = saved_selections.copy()\n                user_data[user_id][\"multi_select_node\"] = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n                user_data[user_id][\"multi_select_type\"] = \"inline\"\n                user_data[user_id][\"multi_select_variable\"] = \"metro_lines\"\n                logging.info(f\"Инициализировано состояние множественного выбора с {len(saved_selections)} элементами\")\n                \n                builder = InlineKeyboardBuilder()\n                # Кнопка выбора с галочками: Красная ветка 🟥\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Красная ветка 🟥' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Красная ветка 🟥\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Красная ветка 🟥': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Красная ветка 🟥\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_red_line'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_red_line\"))\n                # Кнопка выбора с галочками: Синяя ветка 🟦\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Синяя ветка 🟦' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Синяя ветка 🟦\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Синяя ветка 🟦': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Синяя ветка 🟦\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_lue_line'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_lue_line\"))\n                # Кнопка выбора с галочками: Зелёная ветка 🟩\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Зелёная ветка 🟩' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Зелёная ветка 🟩\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Зелёная ветка 🟩': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Зелёная ветка 🟩\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_een_line'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_een_line\"))\n                # Кнопка выбора с галочками: Оранжевая ветка 🟧\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Оранжевая ветка 🟧' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Оранжевая ветка 🟧\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Оранжевая ветка 🟧': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Оранжевая ветка 🟧\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_nge_line'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_nge_line\"))\n                # Кнопка выбора с галочками: Фиолетовая ветка 🟪\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Фиолетовая ветка 🟪' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Фиолетовая ветка 🟪\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Фиолетовая ветка 🟪': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Фиолетовая ветка 🟪\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_ple_line'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_ple_line\"))\n                # Кнопка выбора с галочками: Я из ЛО 🏡\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Я из ЛО 🏡' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Я из ЛО 🏡\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Я из ЛО 🏡': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Я из ЛО 🏡\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_o_cities'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_o_cities\"))\n                # Кнопка выбора с галочками: Я не в Питере 🌍\n                logging.info(f\"🔧 ПРОВЕРЯЕМ ГАЛОЧКУ: ищем 'Я не в Питере 🌍' в списке: {user_data[user_id]['multi_select_metro_selection_paste_1754804051442_a12dc5bu6']}\")\n                selected_mark = \"✅ \" if \"Я не в Питере 🌍\" in user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] else \"\"\n                logging.info(f\"🔍 РЕЗУЛЬТАТ ГАЛОЧКИ для 'Я не в Питере 🌍': selected_mark='{selected_mark}'\")\n                final_text = f\"{selected_mark}Я не в Питере 🌍\"\n                logging.info(f\"📱 СОЗДАЕМ КНОПКУ: text='{final_text}', callback_data='ms_a12dc5bu6_t_in_spb'\")\n                builder.add(InlineKeyboardButton(text=final_text, callback_data=\"ms_a12dc5bu6_t_in_spb\"))\n                # Кнопка \"Готово\" для множественного выбора\n                logging.info(f\"🔘 Создаем кнопку Готово -> done_a12dc5bu6\")\n                builder.add(InlineKeyboardButton(text=\"Готово\", callback_data=\"done_a12dc5bu6\"))\n                builder.adjust(2)\n                keyboard = builder.as_markup()\n                await message.answer(text, reply_markup=keyboard, parse_mode=parse_mode)\n            else:\n                logging.warning(f\"Неизвестный следующий узел: {next_node_id}\")\n        except Exception as e:\n            logging.error(f\"Ошибка при переходе к следующему узлу {next_node_id}: {e}\")\n\n\n# Обработчик для условных кнопок\n@dp.callback_query(lambda c: c.data.startswith(\"conditional_\"))\nasync def handle_conditional_button(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    \n    # Парсим callback_data: conditional_variableName_value\n    callback_parts = callback_query.data.split(\"_\", 2)\n    if len(callback_parts) >= 3:\n        variable_name = callback_parts[1]\n        variable_value = callback_parts[2]\n        \n        user_id = callback_query.from_user.id\n        \n        # Сохраняем значение в базу данных\n        await update_user_data_in_db(user_id, variable_name, variable_value)\n        \n        # Сохраняем в локальные данные\n        if user_id not in user_data:\n            user_data[user_id] = {}\n        user_data[user_id][variable_name] = variable_value\n        \n        logging.info(f\"Условная кнопка: {variable_name} = {variable_value} (пользователь {user_id})\")\n        \n        # После обновления значения автоматически вызываем профиль\n        await callback_query.answer(f\"✅ {variable_name} обновлено\")\n        \n        # Создаем имитацию сообщения для вызова команды профиль\n        class FakeMessage:\n            def __init__(self, callback_query):\n                self.from_user = callback_query.from_user\n                self.chat = callback_query.message.chat\n                self.date = callback_query.message.date\n                self.message_id = callback_query.message.message_id\n            \n            async def answer(self, text, parse_mode=None, reply_markup=None):\n                if reply_markup:\n                    await bot.send_message(self.chat.id, text, parse_mode=parse_mode, reply_markup=reply_markup)\n                else:\n                    await bot.send_message(self.chat.id, text, parse_mode=parse_mode)\n            \n            async def edit_text(self, text, parse_mode=None, reply_markup=None):\n                try:\n                    await bot.edit_message_text(text, self.chat.id, self.message_id, parse_mode=parse_mode, reply_markup=reply_markup)\n                except Exception:\n                    await self.answer(text, parse_mode, reply_markup)\n        \n        fake_message = FakeMessage(callback_query)\n        \n        # Вызываем обработчик профиля\n        try:\n            await profile_handler(fake_message)\n        except Exception as e:\n            logging.error(f\"Ошибка вызова profile_handler: {e}\")\n            await callback_query.message.answer(f\"✅ Значение {variable_name} обновлено на: {variable_value}\")\n    else:\n        logging.warning(f\"Неверный формат условной кнопки: {callback_query.data}\")\n        await callback_query.answer(\"❌ Ошибка обработки кнопки\", show_alert=True)\n\n\n# Обработчики для кнопок команд\n# Найдено 1 кнопок команд: cmd_start\n\n@dp.callback_query(lambda c: c.data == \"cmd_start\")\nasync def handle_cmd_start(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    logging.info(f\"Обработка кнопки команды: cmd_start -> /start (пользователь {callback_query.from_user.id})\")\n    # Симулируем выполнение команды /start\n    \n    # Создаем fake message object для команды\n    from types import SimpleNamespace\n    fake_message = SimpleNamespace()\n    fake_message.from_user = callback_query.from_user\n    fake_message.chat = callback_query.message.chat\n    fake_message.date = callback_query.message.date\n    fake_message.answer = callback_query.message.answer\n    fake_message.edit_text = callback_query.message.edit_text\n    \n    # Вызываем start handler через edit_text\n    # Создаем специальный объект для редактирования сообщения\n    class FakeMessageEdit:\n        def __init__(self, callback_query):\n            self.from_user = callback_query.from_user\n            self.chat = callback_query.message.chat\n            self.date = callback_query.message.date\n            self.message_id = callback_query.message.message_id\n            self._callback_query = callback_query\n        \n        async def answer(self, text, parse_mode=None, reply_markup=None):\n            await self._callback_query.message.edit_text(text, parse_mode=parse_mode, reply_markup=reply_markup)\n        \n        async def edit_text(self, text, parse_mode=None, reply_markup=None):\n            await self._callback_query.message.edit_text(text, parse_mode=parse_mode, reply_markup=reply_markup)\n    \n    fake_edit_message = FakeMessageEdit(callback_query)\n    await start_handler(fake_edit_message)\n    logging.info(f\"Команда /start выполнена через callback кнопку (пользователь {callback_query.from_user.id})\")\n\n\n# Обработчик команды профиля с поддержкой variableLabel\n@dp.message(Command(\"profile\"))\nasync def profile_handler(message: types.Message):\n    user_id = message.from_user.id\n    \n    # Получаем данные пользователя из базы данных\n    user_record = await get_user_from_db(user_id)\n    if not user_record:\n        user_record = user_data.get(user_id, {})\n    \n    # Извлекаем пользовательские данные\n    if isinstance(user_record, dict):\n        if \"user_data\" in user_record:\n            if isinstance(user_record[\"user_data\"], str):\n                try:\n                    import json\n                    user_vars = json.loads(user_record[\"user_data\"])\n                except (json.JSONDecodeError, TypeError):\n                    user_vars = {}\n            elif isinstance(user_record[\"user_data\"], dict):\n                user_vars = user_record[\"user_data\"]\n            else:\n                user_vars = {}\n        else:\n            user_vars = user_record\n    else:\n        user_vars = {}\n    \n    if not user_vars:\n        await message.answer(\"👤 Профиль недоступен\\n\\nПохоже, вы еще не прошли опрос. Пожалуйста, введите /start чтобы заполнить профиль.\")\n        return\n    \n    # Формируем сообщение профиля с поддержкой variableLabel\n    profile_text = \"👤 Ваш профиль:\\n\\n\"\n    \n    # Отображаем все доступные переменные\n    for var_name, var_data in user_vars.items():\n        if isinstance(var_data, dict) and \"value\" in var_data:\n            value = var_data[\"value\"]\n        else:\n            value = var_data\n        profile_text += f\"{var_name}: {value}\\n\"\n    \n    await message.answer(profile_text)\n    logging.info(f\"Профиль отображен для пользователя {user_id}\")\n\n\n\n# Запуск бота\nasync def main():\n    global db_pool\n    try:\n        # Инициализируем базу данных\n        await init_database()\n        print(\"🤖 Бот запущен и готов к работе!\")\n        await dp.start_polling(bot)\n    except KeyboardInterrupt:\n        print(\"🛑 Получен сигнал остановки, завершаем работу...\")\n    except Exception as e:\n        logging.error(f\"Критическая ошибка: {e}\")\n    finally:\n        # Правильно закрываем все соединения\n        if db_pool:\n            await db_pool.close()\n            print(\"🔌 Соединение с базой данных закрыто\")\n        \n        # Закрываем сессию бота\n        await bot.session.close()\n        print(\"🔌 Сессия бота закрыта\")\n        print(\"✅ Бот корректно завершил работу\")\n\n\n# Обработчики для множественного выбора\n@dp.callback_query(lambda c: c.data.startswith(\"ms_\") or c.data.startswith(\"multi_select_\"))\nasync def handle_multi_select_callback(callback_query: types.CallbackQuery):\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    callback_data = callback_query.data\n    \n    # Обработка кнопки \"Готово\"\n    if callback_data.startswith(\"done_\"):\n        # Завершение множественного выбора (новый формат)\n        logging.info(f\"🏁 Обработка кнопки Готово: {callback_data}\")\n        short_node_id = callback_data.replace(\"done_\", \"\")\n        # Находим полный node_id по короткому суффиксу\n        node_id = None\n        if short_node_id == \"start\":\n            node_id = \"start\"\n            logging.info(f\"✅ Найден узел: start\")\n        if short_node_id == \"a12dc5bu6\":\n            node_id = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n            logging.info(f\"✅ Найден узел: metro_selection_paste_1754804051442_a12dc5bu6\")\n    elif callback_data.startswith(\"multi_select_done_\"):\n        # Завершение множественного выбора (старый формат)\n        node_id = callback_data.replace(\"multi_select_done_\", \"\")\n        selected_options = user_data.get(user_id, {}).get(f\"multi_select_{node_id}\", [])\n        \n        # Сохраняем выбранные опции в базу данных\n        if selected_options:\n            selected_text = \", \".join(selected_options)\n            if node_id == \"start\":\n                await save_user_data_to_db(user_id, \"user_interests\", selected_text)\n            if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n                await save_user_data_to_db(user_id, \"metro_lines\", selected_text)\n            # Резервное сохранение если узел не найден\n            if not any(node_id == node for node in [\"start\", \"metro_selection_paste_1754804051442_a12dc5bu6\"]):\n                await save_user_data_to_db(user_id, f\"multi_select_{node_id}\", selected_text)\n        \n        # Очищаем состояние множественного выбора\n        if user_id in user_data:\n            user_data[user_id].pop(f\"multi_select_{node_id}\", None)\n            user_data[user_id].pop(\"multi_select_node\", None)\n        \n        # Переходим к следующему узлу, если указан\n        # Определяем следующий узел для каждого node_id\n        if node_id == \"start\":\n            # Переход к узлу metro_selection_paste_1754804051442_a12dc5bu6\n            logging.info(f\"🔄 Переходим к узлу metro_selection_paste_1754804051442_a12dc5bu6 (тип: message)\")\n            await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(callback_query)\n        if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n            # Переход к узлу interests_result\n            logging.info(f\"🔄 Переходим к узлу interests_result (тип: message)\")\n            await handle_callback_interests_result(callback_query)\n        return\n    \n    # Обработка выбора опции\n    logging.info(f\"📱 Обрабатываем callback_data: {callback_data}\")\n    \n    # Поддерживаем и новый формат ms_ и старый multi_select_\n    if callback_data.startswith(\"ms_\"):\n        # Новый короткий формат: ms_shortNodeId_shortTarget\n        parts = callback_data.split(\"_\")\n        if len(parts) >= 3:\n            short_node_id = parts[1]\n            button_id = \"_\".join(parts[2:])\n            # Находим полный node_id по короткому суффиксу\n            node_id = None\n            logging.info(f\"🔍 Ищем узел по короткому ID: {short_node_id}\")\n            if short_node_id == \"start\":\n                node_id = \"start\"\n                logging.info(f\"✅ Найден узел: {node_id}\")\n            if short_node_id == \"a12dc5bu6\":\n                node_id = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n                logging.info(f\"✅ Найден узел: {node_id}\")\n    elif callback_data.startswith(\"multi_select_\"):\n        # Старый формат для обратной совместимости\n        parts = callback_data.split(\"_\")\n        if len(parts) >= 3:\n            node_id = parts[2]\n            button_id = \"_\".join(parts[3:]) if len(parts) > 3 else parts[2]\n    else:\n        logging.warning(f\"⚠️ Неизвестный формат callback_data: {callback_data}\")\n        return\n    \n    if not node_id:\n        logging.warning(f\"⚠️ Не удалось найти node_id для callback_data: {callback_data}\")\n        return\n    \n    logging.info(f\"📱 Определили node_id: {node_id}, button_id: {button_id}\")\n    \n    # Инициализируем список выбранных опций с восстановлением из БД\n    if user_id not in user_data:\n        user_data[user_id] = {}\n    \n    # Восстанавливаем ранее выбранные опции из базы данных\n    if f\"multi_select_{node_id}\" not in user_data[user_id]:\n        # Загружаем сохраненные данные из базы\n        user_vars = await get_user_from_db(user_id)\n        saved_selections = []\n        \n        if user_vars:\n            # Ищем переменную с интересами\n            for var_name, var_data in user_vars.items():\n                if \"интерес\" in var_name.lower() or var_name == \"interests\" or var_name.startswith(\"multi_select_\"):\n                    if isinstance(var_data, dict) and \"value\" in var_data:\n                        saved_str = var_data[\"value\"]\n                    elif isinstance(var_data, str):\n                        saved_str = var_data\n                    else:\n                        saved_str = str(var_data) if var_data else \"\"\n                    \n                    if saved_str:\n                        saved_selections = [item.strip() for item in saved_str.split(\",\")]\n                        break\n        \n        user_data[user_id][f\"multi_select_{node_id}\"] = saved_selections\n    \n    # Находим текст кнопки по button_id\n    button_text = None\n    if node_id == \"start\":\n        if button_id == \"sport\":\n            button_text = \"⚽ Спорт\"\n        if button_id == \"music\":\n            button_text = \"🎵 Музыка\"\n        if button_id == \"books\":\n            button_text = \"📚 Книги\"\n        if button_id == \"travel\":\n            button_text = \"✈️ Путешествия\"\n        if button_id == \"tech\":\n            button_text = \"💻 Технологии\"\n        if button_id == \"cooking\":\n            button_text = \"🍳 Кулинария\"\n        if button_id == \"art\":\n            button_text = \"🎨 Искусство\"\n        if button_id == \"games\":\n            button_text = \"🎮 Игры\"\n    if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n        if button_id == \"red_line\":\n            button_text = \"Красная ветка 🟥\"\n        if button_id == \"blue_line\":\n            button_text = \"Синяя ветка 🟦\"\n        if button_id == \"green_line\":\n            button_text = \"Зелёная ветка 🟩\"\n        if button_id == \"orange_line\":\n            button_text = \"Оранжевая ветка 🟧\"\n        if button_id == \"purple_line\":\n            button_text = \"Фиолетовая ветка 🟪\"\n        if button_id == \"lo_cities\":\n            button_text = \"Я из ЛО 🏡\"\n        if button_id == \"not_in_spb\":\n            button_text = \"Я не в Питере 🌍\"\n    \n    if button_text:\n        logging.info(f\"🔘 Обрабатываем кнопку: {button_text}\")\n        selected_list = user_data[user_id][f\"multi_select_{node_id}\"]\n        if button_text in selected_list:\n            # Убираем из выбранных\n            selected_list.remove(button_text)\n            logging.info(f\"➖ Убрали выбор: {button_text}\")\n        else:\n            # Добавляем к выбранным\n            selected_list.append(button_text)\n            logging.info(f\"➕ Добавили выбор: {button_text}\")\n        \n        logging.info(f\"📋 Текущие выборы: {selected_list}\")\n        \n        # Обновляем клавиатуру с галочками\n        builder = InlineKeyboardBuilder()\n        if node_id == \"start\":\n            selected_mark = \"✅ \" if \"⚽ Спорт\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}⚽ Спорт\", callback_data=\"multi_select_start_sport\"))\n            selected_mark = \"✅ \" if \"🎵 Музыка\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}🎵 Музыка\", callback_data=\"multi_select_start_music\"))\n            selected_mark = \"✅ \" if \"📚 Книги\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}📚 Книги\", callback_data=\"multi_select_start_books\"))\n            selected_mark = \"✅ \" if \"✈️ Путешествия\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}✈️ Путешествия\", callback_data=\"multi_select_start_travel\"))\n            selected_mark = \"✅ \" if \"💻 Технологии\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}💻 Технологии\", callback_data=\"multi_select_start_tech\"))\n            selected_mark = \"✅ \" if \"🍳 Кулинария\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}🍳 Кулинария\", callback_data=\"multi_select_start_cooking\"))\n            selected_mark = \"✅ \" if \"🎨 Искусство\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}🎨 Искусство\", callback_data=\"multi_select_start_art\"))\n            selected_mark = \"✅ \" if \"🎮 Игры\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}🎮 Игры\", callback_data=\"multi_select_start_games\"))\n            builder.add(InlineKeyboardButton(text=\"Готово\", callback_data=\"multi_select_done_start\"))\n            builder.adjust(2, 2, 2, 2, 1)\n        if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n            selected_mark = \"✅ \" if \"Красная ветка 🟥\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Красная ветка 🟥\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_red_line\"))\n            selected_mark = \"✅ \" if \"Синяя ветка 🟦\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Синяя ветка 🟦\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_lue_line\"))\n            selected_mark = \"✅ \" if \"Зелёная ветка 🟩\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Зелёная ветка 🟩\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_een_line\"))\n            selected_mark = \"✅ \" if \"Оранжевая ветка 🟧\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Оранжевая ветка 🟧\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_nge_line\"))\n            selected_mark = \"✅ \" if \"Фиолетовая ветка 🟪\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Фиолетовая ветка 🟪\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_ple_line\"))\n            selected_mark = \"✅ \" if \"Я из ЛО 🏡\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Я из ЛО 🏡\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_o_cities\"))\n            selected_mark = \"✅ \" if \"Я не в Питере 🌍\" in selected_list else \"\"\n            builder.add(InlineKeyboardButton(text=f\"{selected_mark}Я не в Питере 🌍\", callback_data=\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6_t_in_spb\"))\n            builder.add(InlineKeyboardButton(text=\"Готово\", callback_data=\"multi_select_done_metro_selection_paste_1754804051442_a12dc5bu6\"))\n            builder.adjust(2, 2, 2, 2, 1)\n        \n        keyboard = builder.as_markup()\n        await callback_query.message.edit_reply_markup(reply_markup=keyboard)\n\n# Обработчик для кнопок завершения множественного выбора\n@dp.callback_query(lambda callback_query: callback_query.data and callback_query.data.startswith(\"multi_select_done_\"))\nasync def handle_multi_select_done(callback_query: types.CallbackQuery):\n    logging.info(f\"🏁 ОБРАБОТЧИК ГОТОВО АКТИВИРОВАН! callback_data: {callback_query.data}\")\n    await callback_query.answer()\n    user_id = callback_query.from_user.id\n    callback_data = callback_query.data\n    \n    logging.info(f\"🏁 Завершение множественного выбора: {callback_data}\")\n    logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: Текущее сообщение ID: {callback_query.message.message_id}\")\n    logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: Текущий текст сообщения: {callback_query.message.text}\")\n    logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: Есть ли клавиатура: {bool(callback_query.message.reply_markup)}\")\n    \n    # Извлекаем node_id из callback_data\n    node_id = callback_data.replace(\"multi_select_done_\", \"\")\n    logging.info(f\"🎯 Node ID для завершения: {node_id}\")\n    \n    if node_id == \"start\":\n        logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: Обрабатываем завершение для узла start\")\n        logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: continueButtonTarget = metro_selection_paste_1754804051442_a12dc5bu6\")\n        # Получаем выбранные опции для узла start\n        selected_options = user_data.get(user_id, {}).get(\"multi_select_start\", [])\n        logging.info(f\"📋 ГЕНЕРАТОР DEBUG: Выбранные опции для start: {selected_options}\")\n        \n        if selected_options:\n            selected_text = \", \".join(selected_options)\n            await save_user_data_to_db(user_id, \"user_interests\", selected_text)\n            logging.info(f\"💾 ГЕНЕРАТОР DEBUG: Сохранили в БД: user_interests = {selected_text}\")\n        else:\n            logging.info(f\"⚠️ ГЕНЕРАТОР DEBUG: Нет выбранных опций для сохранения\")\n        \n        # Переход к следующему узлу: metro_selection_paste_1754804051442_a12dc5bu6\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Переходим к узлу {continueButtonTarget}\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Тип целевого узла: message\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: allowMultipleSelection: true\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Есть ли кнопки: 7\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: keyboardType: inline\")\n        # Узел metro_selection_paste_1754804051442_a12dc5bu6 поддерживает множественный выбор - сохраняем состояние\n        logging.info(f\"🔧 ГЕНЕРАТОР DEBUG: Инициализируем множественный выбор для узла metro_selection_paste_1754804051442_a12dc5bu6\")\n        if user_id not in user_data:\n            user_data[user_id] = {}\n        user_data[user_id][\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\"] = []\n        user_data[user_id][\"multi_select_node\"] = \"metro_selection_paste_1754804051442_a12dc5bu6\"\n        user_data[user_id][\"multi_select_type\"] = \"inline\"\n        logging.info(f\"🔧 ГЕНЕРАТОР DEBUG: Состояние множественного выбора установлено для узла metro_selection_paste_1754804051442_a12dc5bu6\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Вызываем handle_callback_{safeFunctionName}\")\n        await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(callback_query)\n        return\n    \n    if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n        logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: Обрабатываем завершение для узла metro_selection_paste_1754804051442_a12dc5bu6\")\n        logging.info(f\"🔍 ГЕНЕРАТОР DEBUG: continueButtonTarget = interests_result\")\n        # Получаем выбранные опции для узла metro_selection_paste_1754804051442_a12dc5bu6\n        selected_options = user_data.get(user_id, {}).get(\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\", [])\n        logging.info(f\"📋 ГЕНЕРАТОР DEBUG: Выбранные опции для metro_selection_paste_1754804051442_a12dc5bu6: {selected_options}\")\n        \n        if selected_options:\n            selected_text = \", \".join(selected_options)\n            await save_user_data_to_db(user_id, \"metro_lines\", selected_text)\n            logging.info(f\"💾 ГЕНЕРАТОР DEBUG: Сохранили в БД: metro_lines = {selected_text}\")\n        else:\n            logging.info(f\"⚠️ ГЕНЕРАТОР DEBUG: Нет выбранных опций для сохранения\")\n        \n        # Переход к следующему узлу: interests_result\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Переходим к узлу {continueButtonTarget}\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Тип целевого узла: message\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: allowMultipleSelection: false\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Есть ли кнопки: 2\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: keyboardType: inline\")\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Вызываем handle_callback_{safeFunctionName}\")\n        # ИСПРАВЛЕНИЕ: Специальная обработка для interests_result - сохраняем метро клавиатуру\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Обрабатываем переход к interests_result - сохраняем метро состояние\")\n        # Сохраняем состояние метро для следующего узла\n        metro_state = user_data.get(user_id, {}).get(\"multi_select_metro_selection_paste_1754804051442_a12dc5bu6\", [])\n        if user_id not in user_data:\n            user_data[user_id] = {}\n        user_data[user_id][\"saved_metro_selection\"] = metro_state\n        user_data[user_id][\"show_metro_keyboard\"] = True\n        logging.info(f\"🚀 ГЕНЕРАТОР DEBUG: Сохранили метро состояние: {metro_state}\")\n        await handle_callback_interests_result(callback_query)\n        return\n    \n\n# Обработчик для reply кнопок множественного выбора\n@dp.message()\nasync def handle_multi_select_reply(message: types.Message):\n    user_id = message.from_user.id\n    user_input = message.text\n    \n    # Проверяем, находится ли пользователь в режиме множественного выбора reply\n    if user_id in user_data and \"multi_select_node\" in user_data[user_id] and user_data[user_id].get(\"multi_select_type\") == \"reply\":\n        node_id = user_data[user_id][\"multi_select_node\"]\n        \n        if node_id == \"start\" and user_input == \"Готово\":\n            # Завершение множественного выбора для узла start\n            selected_options = user_data.get(user_id, {}).get(\"multi_select_{node_id}\", [])\n            if selected_options:\n                selected_text = \", \".join(selected_options)\n                await save_user_data_to_db(user_id, \"user_interests\", selected_text)\n            \n            # Очищаем состояние\n            user_data[user_id].pop(\"multi_select_{node_id}\", None)\n            user_data[user_id].pop(\"multi_select_node\", None)\n            user_data[user_id].pop(\"multi_select_type\", None)\n            \n            # Переход к следующему узлу\n            await handle_callback_metro_selection_paste_1754804051442_a12dc5bu6(types.CallbackQuery(id=\"multi_select\", from_user=message.from_user, chat_instance=\"\", data=\"metro_selection_paste_1754804051442_a12dc5bu6\", message=message))\n            return\n        \n        if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\" and user_input == \"Готово\":\n            # Завершение множественного выбора для узла metro_selection_paste_1754804051442_a12dc5bu6\n            selected_options = user_data.get(user_id, {}).get(\"multi_select_{node_id}\", [])\n            if selected_options:\n                selected_text = \", \".join(selected_options)\n                await save_user_data_to_db(user_id, \"metro_lines\", selected_text)\n            \n            # Очищаем состояние\n            user_data[user_id].pop(\"multi_select_{node_id}\", None)\n            user_data[user_id].pop(\"multi_select_node\", None)\n            user_data[user_id].pop(\"multi_select_type\", None)\n            \n            # Переход к следующему узлу\n            await handle_callback_interests_result(types.CallbackQuery(id=\"multi_select\", from_user=message.from_user, chat_instance=\"\", data=\"interests_result\", message=message))\n            return\n        \n        # Обработка выбора опции\n        if node_id == \"start\":\n            if user_input == \"⚽ Спорт\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"⚽ Спорт\" in selected_list:\n                    selected_list.remove(\"⚽ Спорт\")\n                    await message.answer(\"❌ Убрано: ⚽ Спорт\")\n                else:\n                    selected_list.append(\"⚽ Спорт\")\n                    await message.answer(\"✅ Выбрано: ⚽ Спорт\")\n                return\n            \n            if user_input == \"🎵 Музыка\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"🎵 Музыка\" in selected_list:\n                    selected_list.remove(\"🎵 Музыка\")\n                    await message.answer(\"❌ Убрано: 🎵 Музыка\")\n                else:\n                    selected_list.append(\"🎵 Музыка\")\n                    await message.answer(\"✅ Выбрано: 🎵 Музыка\")\n                return\n            \n            if user_input == \"📚 Книги\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"📚 Книги\" in selected_list:\n                    selected_list.remove(\"📚 Книги\")\n                    await message.answer(\"❌ Убрано: 📚 Книги\")\n                else:\n                    selected_list.append(\"📚 Книги\")\n                    await message.answer(\"✅ Выбрано: 📚 Книги\")\n                return\n            \n            if user_input == \"✈️ Путешествия\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"✈️ Путешествия\" in selected_list:\n                    selected_list.remove(\"✈️ Путешествия\")\n                    await message.answer(\"❌ Убрано: ✈️ Путешествия\")\n                else:\n                    selected_list.append(\"✈️ Путешествия\")\n                    await message.answer(\"✅ Выбрано: ✈️ Путешествия\")\n                return\n            \n            if user_input == \"💻 Технологии\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"💻 Технологии\" in selected_list:\n                    selected_list.remove(\"💻 Технологии\")\n                    await message.answer(\"❌ Убрано: 💻 Технологии\")\n                else:\n                    selected_list.append(\"💻 Технологии\")\n                    await message.answer(\"✅ Выбрано: 💻 Технологии\")\n                return\n            \n            if user_input == \"🍳 Кулинария\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"🍳 Кулинария\" in selected_list:\n                    selected_list.remove(\"🍳 Кулинария\")\n                    await message.answer(\"❌ Убрано: 🍳 Кулинария\")\n                else:\n                    selected_list.append(\"🍳 Кулинария\")\n                    await message.answer(\"✅ Выбрано: 🍳 Кулинария\")\n                return\n            \n            if user_input == \"🎨 Искусство\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"🎨 Искусство\" in selected_list:\n                    selected_list.remove(\"🎨 Искусство\")\n                    await message.answer(\"❌ Убрано: 🎨 Искусство\")\n                else:\n                    selected_list.append(\"🎨 Искусство\")\n                    await message.answer(\"✅ Выбрано: 🎨 Искусство\")\n                return\n            \n            if user_input == \"🎮 Игры\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"🎮 Игры\" in selected_list:\n                    selected_list.remove(\"🎮 Игры\")\n                    await message.answer(\"❌ Убрано: 🎮 Игры\")\n                else:\n                    selected_list.append(\"🎮 Игры\")\n                    await message.answer(\"✅ Выбрано: 🎮 Игры\")\n                return\n            \n        if node_id == \"metro_selection_paste_1754804051442_a12dc5bu6\":\n            if user_input == \"Красная ветка 🟥\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Красная ветка 🟥\" in selected_list:\n                    selected_list.remove(\"Красная ветка 🟥\")\n                    await message.answer(\"❌ Убрано: Красная ветка 🟥\")\n                else:\n                    selected_list.append(\"Красная ветка 🟥\")\n                    await message.answer(\"✅ Выбрано: Красная ветка 🟥\")\n                return\n            \n            if user_input == \"Синяя ветка 🟦\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Синяя ветка 🟦\" in selected_list:\n                    selected_list.remove(\"Синяя ветка 🟦\")\n                    await message.answer(\"❌ Убрано: Синяя ветка 🟦\")\n                else:\n                    selected_list.append(\"Синяя ветка 🟦\")\n                    await message.answer(\"✅ Выбрано: Синяя ветка 🟦\")\n                return\n            \n            if user_input == \"Зелёная ветка 🟩\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Зелёная ветка 🟩\" in selected_list:\n                    selected_list.remove(\"Зелёная ветка 🟩\")\n                    await message.answer(\"❌ Убрано: Зелёная ветка 🟩\")\n                else:\n                    selected_list.append(\"Зелёная ветка 🟩\")\n                    await message.answer(\"✅ Выбрано: Зелёная ветка 🟩\")\n                return\n            \n            if user_input == \"Оранжевая ветка 🟧\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Оранжевая ветка 🟧\" in selected_list:\n                    selected_list.remove(\"Оранжевая ветка 🟧\")\n                    await message.answer(\"❌ Убрано: Оранжевая ветка 🟧\")\n                else:\n                    selected_list.append(\"Оранжевая ветка 🟧\")\n                    await message.answer(\"✅ Выбрано: Оранжевая ветка 🟧\")\n                return\n            \n            if user_input == \"Фиолетовая ветка 🟪\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Фиолетовая ветка 🟪\" in selected_list:\n                    selected_list.remove(\"Фиолетовая ветка 🟪\")\n                    await message.answer(\"❌ Убрано: Фиолетовая ветка 🟪\")\n                else:\n                    selected_list.append(\"Фиолетовая ветка 🟪\")\n                    await message.answer(\"✅ Выбрано: Фиолетовая ветка 🟪\")\n                return\n            \n            if user_input == \"Я из ЛО 🏡\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Я из ЛО 🏡\" in selected_list:\n                    selected_list.remove(\"Я из ЛО 🏡\")\n                    await message.answer(\"❌ Убрано: Я из ЛО 🏡\")\n                else:\n                    selected_list.append(\"Я из ЛО 🏡\")\n                    await message.answer(\"✅ Выбрано: Я из ЛО 🏡\")\n                return\n            \n            if user_input == \"Я не в Питере 🌍\":\n                if \"multi_select_{node_id}\" not in user_data[user_id]:\n                    user_data[user_id][\"multi_select_{node_id}\"] = []\n                \n                selected_list = user_data[user_id][\"multi_select_{node_id}\"]\n                if \"Я не в Питере 🌍\" in selected_list:\n                    selected_list.remove(\"Я не в Питере 🌍\")\n                    await message.answer(\"❌ Убрано: Я не в Питере 🌍\")\n                else:\n                    selected_list.append(\"Я не в Питере 🌍\")\n                    await message.answer(\"✅ Выбрано: Я не в Питере 🌍\")\n                return\n            \n    \n    # Если не множественный выбор, передаем дальше по цепочке обработчиков\n    pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"}